// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "generator/internal/stub_generator.h"
#include "generator/internal/codegen_utils.h"
#include "generator/internal/descriptor_utils.h"
#include "generator/internal/longrunning.h"
#include "generator/internal/predicate_utils.h"
#include "generator/internal/printer.h"
#include "google/cloud/internal/absl_str_cat_quiet.h"
#include "google/cloud/internal/absl_str_join_quiet.h"
#include "absl/strings/str_split.h"
#include <google/protobuf/descriptor.h>

namespace google {
namespace cloud {
namespace generator_internal {

StubGenerator::StubGenerator(
    google::protobuf::ServiceDescriptor const* service_descriptor,
    VarsDictionary service_vars,
    std::map<std::string, VarsDictionary> service_method_vars,
    google::protobuf::compiler::GeneratorContext* context,
    std::vector<MixinMethod> const& mixin_methods)
    : StubGeneratorBase("stub_header_path", "stub_cc_path", service_descriptor,
                        std::move(service_vars), std::move(service_method_vars),
                        context, mixin_methods) {}

Status StubGenerator::GenerateHeader() {
  HeaderPrint(CopyrightLicenseFileHeader());
  HeaderPrint(  // clang-format off
    "\n"
    "// Generated by the Codegen C++ plugin.\n"
    "// If you make any local changes, they will be lost.\n"
    "// source: $proto_file_name$\n"
    "\n"
    "#ifndef $header_include_guard$\n"
    "#define $header_include_guard$\n");
  // clang-format on

  // includes
  HeaderPrint("\n");
  auto const needs_completion_queue =
      HasAsyncMethod() || HasBidirStreamingMethod();
  HeaderLocalIncludes(
      {HasBidirStreamingMethod()
           ? "google/cloud/async_streaming_read_write_rpc.h"
           : "",
       needs_completion_queue ? "google/cloud/completion_queue.h" : "",
       HasAsyncMethod() ? "google/cloud/future.h" : "",
       HasAsynchronousStreamingReadMethod()
           ? "google/cloud/internal/async_streaming_read_rpc.h"
           : "",
       HasAsynchronousStreamingWriteMethod()
           ? "google/cloud/internal/async_streaming_write_rpc.h"
           : "",
       HasStreamingReadMethod() ? "google/cloud/internal/streaming_read_rpc.h"
                                : "",
       HasStreamingWriteMethod() ? "google/cloud/internal/streaming_write_rpc.h"
                                 : "",
       "google/cloud/options.h", "google/cloud/status_or.h",
       "google/cloud/version.h"});
  std::vector<std::string> additional_pb_header_paths =
      absl::StrSplit(vars("additional_pb_header_paths"), absl::ByChar(','));
  HeaderSystemIncludes(additional_pb_header_paths);
  std::vector<std::string> mixin_headers =
      absl::StrSplit(vars("mixin_proto_grpc_header_paths"), ',');
  HeaderSystemIncludes(mixin_headers);
  bool include_lro_header =
      HasLongrunningMethod() &&
      std::find(mixin_headers.begin(), mixin_headers.end(),
                "google/longrunning/operations.grpc.pb.h") ==
          mixin_headers.end();
  HeaderSystemIncludes(
      {vars("proto_grpc_header_path"),
       include_lro_header ? "google/longrunning/operations.grpc.pb.h" : "",
       "memory", "utility"});

  auto result = HeaderOpenNamespaces(NamespaceType::kInternal);
  if (!result.ok()) return result;

  // Abstract interface Stub base class
  HeaderPrint(  // clang-format off
    "\n"
    "class $stub_class_name$ {\n"
    " public:\n"
    "  virtual ~$stub_class_name$() = 0;\n");
  // clang-format on

  for (auto const& method : methods()) {
    if (IsStreamingWrite(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__,
                        R"""(
  virtual std::unique_ptr<::google::cloud::internal::StreamingWriteRpc<
      $request_type$,
      $response_type$>>
  $method_name$(
      std::shared_ptr<grpc::ClientContext> context,
      Options const& options) = 0;
)""");
      continue;
    }
    if (IsBidirStreaming(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__,
                        R"""(
  virtual std::unique_ptr<::google::cloud::AsyncStreamingReadWriteRpc<
      $request_type$,
      $response_type$>>
  Async$method_name$(
      google::cloud::CompletionQueue const& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options) = 0;
)""");
      continue;
    }
    if (IsLongrunningOperation(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual future<StatusOr<google::longrunning::Operation>> Async$method_name$(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options,
      $request_type$ const& request) = 0;
)""");
      HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual StatusOr<google::longrunning::Operation> $method_name$(
      grpc::ClientContext& context,
      Options options,
      $request_type$ const& request) = 0;
)""");
      continue;
    }
    if (IsStreamingRead(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual std::unique_ptr<google::cloud::internal::StreamingReadRpc<$response_type$>>
  $method_name$(
    std::shared_ptr<grpc::ClientContext> context,
    Options const& options,
    $request_type$ const& request) = 0;
)""");
      continue;
    }
    HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual $return_type$ $method_name$(
      grpc::ClientContext& context,
      Options const& options,
      $request_type$ const& request) = 0;
)""");
  }

  for (auto const& method : async_methods()) {
    // Nothing to do, these are always asynchronous.
    if (IsBidirStreaming(method) || IsLongrunningOperation(method)) continue;
    if (IsStreamingRead(method)) {
      auto constexpr kDeclaration = R"""(
  virtual std::unique_ptr<::google::cloud::internal::AsyncStreamingReadRpc<
      $response_type$>>
  Async$method_name$(
      google::cloud::CompletionQueue const& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options,
      $request_type$ const& request) = 0;
)""";
      HeaderPrintMethod(method, __FILE__, __LINE__, kDeclaration);
      continue;
    }
    if (IsStreamingWrite(method)) {
      auto constexpr kDeclaration = R"""(
  virtual std::unique_ptr<::google::cloud::internal::AsyncStreamingWriteRpc<
      $request_type$, $response_type$>>
  Async$method_name$(
      google::cloud::CompletionQueue const& cq,
      std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options) = 0;
)""";
      HeaderPrintMethod(method, __FILE__, __LINE__, kDeclaration);
      continue;
    }
    HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual future<$return_type$>
  Async$method_name$(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options,
    $request_type$ const& request) = 0;
)""");
  }

  // long running operation support methods
  if (HasLongrunningMethod()) {
    HeaderPrint(
        R"""(
  virtual future<StatusOr<google::longrunning::Operation>> AsyncGetOperation(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options,
      google::longrunning::GetOperationRequest const& request) = 0;

  virtual future<Status> AsyncCancelOperation(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options,
      google::longrunning::CancelOperationRequest const& request) = 0;
)""");
  }
  // close abstract interface Stub base class
  HeaderPrint("};\n");

  // default stub class
  HeaderPrint(  // clang-format off
    "\n"
    "class Default$stub_class_name$ : public $stub_class_name$ {\n"
    " public:");
  std::unordered_map<std::string, std::string> mixin_grpc_stubs;
  for (auto const& mixin_method : MixinMethods()) {
    // We create operations stub for service with LRO no matter it has LRO mixin or not, so we skip creating mixin operations stub for the services with LRO.
    if (HasLongrunningMethod() && mixin_method.grpc_stub_name == "operations_stub") continue;
    mixin_grpc_stubs[mixin_method.grpc_stub_name] = mixin_method.grpc_stub_fqn;
  }

  if (HasLongrunningMethod()) {
    HeaderPrint(R"""(
  Default$stub_class_name$(
      std::unique_ptr<$grpc_stub_fqn$::StubInterface> grpc_stub,
    )""");
    for (auto const& mixin_grpc_stub : mixin_grpc_stubs) {
      HeaderPrint(absl::StrFormat(
      R"""(      std::unique_ptr<%s::StubInterface> %s,
)""", mixin_grpc_stub.second, mixin_grpc_stub.first));
    }
    HeaderPrint(R"""(      std::unique_ptr<google::longrunning::Operations::StubInterface> operations_stub)
      : grpc_stub_(std::move(grpc_stub)),
)""");
    for (auto const& mixin_grpc_stub : mixin_grpc_stubs) {
      HeaderPrint(absl::StrFormat(
      R"""(        %s_(std::move(%s)),
)""", mixin_grpc_stub.first, mixin_grpc_stub.first));
    }
    HeaderPrint(R"""(        operations_stub_(std::move(operations_stub)) {}
)""");

  } else {
    HeaderPrint(R"""(
  explicit Default$stub_class_name$(
      std::unique_ptr<$grpc_stub_fqn$::StubInterface> grpc_stub)""");
    for (auto const& mixin_grpc_stub : mixin_grpc_stubs) {
      HeaderPrint(absl::StrFormat(R"""(,
      std::unique_ptr<%s::StubInterface> %s
)""", mixin_grpc_stub.second, mixin_grpc_stub.first));
    }
    HeaderPrint(R"""()
      : grpc_stub_(std::move(grpc_stub)))""");
    for (auto const& mixin_grpc_stub : mixin_grpc_stubs) {
      HeaderPrint(absl::StrFormat(R"""(,
        %s_(std::move(%s)))""", mixin_grpc_stub.first, mixin_grpc_stub.first));
    }
    HeaderPrint(R"""( {}
)""");
  }

  HeaderPrintPublicMethods();

  // private members and close default stub class definition
  HeaderPrint(R"""(
 private:
  std::unique_ptr<$grpc_stub_fqn$::StubInterface> grpc_stub_;
)""");

  for (auto const& mixin_grpc_stub : mixin_grpc_stubs) {
    HeaderPrint(absl::StrFormat(R"""(  std::unique_ptr<%s::StubInterface> %s_;
)""", mixin_grpc_stub.second, mixin_grpc_stub.first));
  }

  if (HasLongrunningMethod()) {
    // TODO(#14746) - clean up operation stubs
    HeaderPrint(  // clang-format off
    "  std::unique_ptr<google::longrunning::Operations::StubInterface> operations_stub_;\n");
    // clang-format on
  }
  HeaderPrint("};\n");

  HeaderCloseNamespaces();
  // close header guard
  HeaderPrint("\n#endif  // $header_include_guard$\n");
  return {};
}

Status StubGenerator::GenerateCc() {
  CcPrint(CopyrightLicenseFileHeader());
  CcPrint(  // clang-format off
    "\n"
    "// Generated by the Codegen C++ plugin.\n"
    "// If you make any local changes, they will be lost.\n"
    "// source: $proto_file_name$\n");
  // clang-format on

  // includes
  CcPrint("\n");
  CcLocalIncludes(
      {vars("stub_header_path"),
       HasBidirStreamingMethod()
           ? "google/cloud/internal/async_read_write_stream_impl.h"
           : "",
       HasAsynchronousStreamingReadMethod()
           ? "google/cloud/internal/async_streaming_read_rpc_impl.h"
           : "",
       HasAsynchronousStreamingWriteMethod()
           ? "google/cloud/internal/async_streaming_write_rpc_impl.h"
           : "",
       HasStreamingWriteMethod()
           ? "google/cloud/internal/streaming_write_rpc_impl.h"
           : "",
       "google/cloud/grpc_error_delegate.h", "google/cloud/status_or.h"});
  CcSystemIncludes(
      {vars("proto_grpc_header_path"),
       HasLongrunningMethod() ? "google/longrunning/operations.grpc.pb.h" : "",
       "memory", "utility"});

  auto result = CcOpenNamespaces(NamespaceType::kInternal);
  if (!result.ok()) return result;

  CcPrint(  // clang-format off
    "\n"
    "$stub_class_name$::~$stub_class_name$() = default;\n");
  // clang-format on

  // default stub class member methods
  for (auto const& method : methods()) {
    if (IsStreamingWrite(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    R"""(
std::unique_ptr<::google::cloud::internal::StreamingWriteRpc<
    $request_type$,
    $response_type$>>
Default$stub_class_name$::$method_name$(
    std::shared_ptr<grpc::ClientContext> context,
    Options const&) {
  auto response = std::make_unique<$response_type$>();
  auto stream = $grpc_stub$->$method_name$(context.get(), response.get());
  return std::make_unique<::google::cloud::internal::StreamingWriteRpcImpl<
      $request_type$, $response_type$>>(
    std::move(context), std::move(response), std::move(stream));
}
)""");
      continue;
    }
    if (IsBidirStreaming(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    R"""(
std::unique_ptr<::google::cloud::AsyncStreamingReadWriteRpc<
    $request_type$,
    $response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue const& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options) {
  return google::cloud::internal::MakeStreamingReadWriteRpc<$request_type$, $response_type$>(
      cq, std::move(context), std::move(options),
      [this](grpc::ClientContext* context, grpc::CompletionQueue* cq) {
        return $grpc_stub$->PrepareAsync$method_name$(context, cq);
      });
}
)""");
      continue;
    }
    if (IsLongrunningOperation(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    R"""(
future<StatusOr<google::longrunning::Operation>>
Default$stub_class_name$::Async$method_name$(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions,
      $request_type$ const& request) {
  return internal::MakeUnaryRpcImpl<$request_type$,
                                    google::longrunning::Operation>(
      cq,
      [this](grpc::ClientContext* context,
             $request_type$ const& request,
             grpc::CompletionQueue* cq) {
        return $grpc_stub$->Async$method_name$(context, request, cq);
      },
      request, std::move(context));
}
)""");

      CcPrintMethod(method, __FILE__, __LINE__,
                    R"""(
StatusOr<google::longrunning::Operation>
Default$stub_class_name$::$method_name$(
      grpc::ClientContext& context,
      Options,
      $request_type$ const& request) {
    $response_type$ response;
    auto status =
        $grpc_stub$->$method_name$(&context, request, &response);
    if (!status.ok()) {
      return google::cloud::MakeStatusFromRpcError(status);
    }
    return response;
}
)""");

      continue;
    }
    if (IsStreamingRead(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    R"""(
std::unique_ptr<google::cloud::internal::StreamingReadRpc<$response_type$>>
Default$stub_class_name$::$method_name$(
    std::shared_ptr<grpc::ClientContext> context,
    Options const&,
    $request_type$ const& request) {
  auto stream = $grpc_stub$->$method_name$(context.get(), request);
  return std::make_unique<google::cloud::internal::StreamingReadRpcImpl<
      $response_type$>>(
      std::move(context), std::move(stream));
}
)""");
      continue;
    }

    if (IsResponseTypeEmpty(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    R"""(
Status
Default$stub_class_name$::$method_name$(
  grpc::ClientContext& context, Options const&,
  $request_type$ const& request) {
    $response_type$ response;
    auto status =
        $grpc_stub$->$method_name$(&context, request, &response);
    if (!status.ok()) {
      return google::cloud::MakeStatusFromRpcError(status);
    }
    return google::cloud::Status();
}
)""");
      continue;
    }
    CcPrintMethod(method, __FILE__, __LINE__,
                  R"""(
StatusOr<$response_type$>
Default$stub_class_name$::$method_name$(
  grpc::ClientContext& context, Options const&,
  $request_type$ const& request) {
    $response_type$ response;
    auto status =
        $grpc_stub$->$method_name$(&context, request, &response);
    if (!status.ok()) {
      return google::cloud::MakeStatusFromRpcError(status);
    }
    return response;
}
)""");
  }

  for (auto const& method : async_methods()) {
    // Nothing to do, these are always asynchronous.
    if (IsBidirStreaming(method) || IsLongrunningOperation(method)) continue;

    if (IsStreamingRead(method)) {
      CcPrintMethod(method, __FILE__, __LINE__, R"""(
std::unique_ptr<::google::cloud::internal::AsyncStreamingReadRpc<
    $response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue const& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options,
    $request_type$ const& request) {
  return google::cloud::internal::MakeStreamingReadRpc<$request_type$, $response_type$>(
    cq, std::move(context), std::move(options), request,
    [this](grpc::ClientContext* context, $request_type$ const& request, grpc::CompletionQueue* cq) {
      return $grpc_stub$->PrepareAsync$method_name$(context, request, cq);
    });
}
)""");
      continue;
    }
    if (IsStreamingWrite(method)) {
      CcPrintMethod(method, __FILE__, __LINE__, R"""(
std::unique_ptr<::google::cloud::internal::AsyncStreamingWriteRpc<
    $request_type$, $response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue const& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options) {
  return google::cloud::internal::MakeStreamingWriteRpc<$request_type$, $response_type$>(
    cq, std::move(context), std::move(options),
    [this](grpc::ClientContext* context, $response_type$* response, grpc::CompletionQueue* cq) {
      return $grpc_stub$->PrepareAsync$method_name$(context, response, cq);
    });
}
)""");
      continue;
    }
    if (IsResponseTypeEmpty(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    R"""(
future<Status>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    $request_type$ const& request) {
  return internal::MakeUnaryRpcImpl<$request_type$,
                                    $response_type$>(
      cq,
      [this](grpc::ClientContext* context,
             $request_type$ const& request,
             grpc::CompletionQueue* cq) {
        return $grpc_stub$->Async$method_name$(context, request, cq);
      },
      request, std::move(context))
          .then([](future<StatusOr<google::protobuf::Empty>> f) {
            return f.get().status();
          });
}
)""");
      continue;
    }
    CcPrintMethod(method, __FILE__, __LINE__,
                  R"""(
future<StatusOr<$response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    $request_type$ const& request) {
  return internal::MakeUnaryRpcImpl<$request_type$,
                                    $response_type$>(
      cq,
      [this](grpc::ClientContext* context,
             $request_type$ const& request,
             grpc::CompletionQueue* cq) {
        return $grpc_stub$->Async$method_name$(context, request, cq);
      },
      request, std::move(context));
}
)""");
  }

  if (HasLongrunningMethod()) {
    CcPrint(R"""(
future<StatusOr<google::longrunning::Operation>>
Default$stub_class_name$::AsyncGetOperation(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    google::longrunning::GetOperationRequest const& request) {
  return internal::MakeUnaryRpcImpl<google::longrunning::GetOperationRequest,
                                    google::longrunning::Operation>(
      cq,
      [this](grpc::ClientContext* context,
             google::longrunning::GetOperationRequest const& request,
             grpc::CompletionQueue* cq) {
        return operations_stub_->AsyncGetOperation(context, request, cq);
      },
      request, std::move(context));
}

future<Status> Default$stub_class_name$::AsyncCancelOperation(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    google::longrunning::CancelOperationRequest const& request) {
  return internal::MakeUnaryRpcImpl<google::longrunning::CancelOperationRequest,
                                    google::protobuf::Empty>(
      cq,
      [this](grpc::ClientContext* context,
             google::longrunning::CancelOperationRequest const& request,
             grpc::CompletionQueue* cq) {
        return operations_stub_->AsyncCancelOperation(context, request, cq);
      },
      request, std::move(context))
      .then([](future<StatusOr<google::protobuf::Empty>> f) {
        return f.get().status();
      });
}
)""");
  }

  CcCloseNamespaces();
  return {};
}

}  // namespace generator_internal
}  // namespace cloud
}  // namespace google
