// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "generator/internal/stub_generator.h"
#include "generator/internal/codegen_utils.h"
#include "generator/internal/descriptor_utils.h"
#include "generator/internal/longrunning.h"
#include "generator/internal/predicate_utils.h"
#include "generator/internal/printer.h"
#include "google/cloud/internal/absl_str_cat_quiet.h"
#include "google/cloud/internal/absl_str_join_quiet.h"
#include "absl/strings/str_split.h"
#include <google/protobuf/descriptor.h>

namespace google {
namespace cloud {
namespace generator_internal {

StubGenerator::StubGenerator(
    google::protobuf::ServiceDescriptor const* service_descriptor,
    VarsDictionary service_vars,
    std::map<std::string, VarsDictionary> service_method_vars,
    google::protobuf::compiler::GeneratorContext* context,
    std::vector<MixinMethod> const& mixin_methods)
    : StubGeneratorBase("stub_header_path", "stub_cc_path", service_descriptor,
                        std::move(service_vars), std::move(service_method_vars),
                        context, mixin_methods) {}

Status StubGenerator::GenerateHeader() {
  HeaderPrint(CopyrightLicenseFileHeader());
  HeaderPrint(  // clang-format off
    "\n"
    "// Generated by the Codegen C++ plugin.\n"
    "// If you make any local changes, they will be lost.\n"
    "// source: $proto_file_name$\n"
    "\n"
    "#ifndef $header_include_guard$\n"
    "#define $header_include_guard$\n");
  // clang-format on

  // includes
  HeaderPrint("\n");
  auto const needs_completion_queue =
      HasAsyncMethod() || HasBidirStreamingMethod();
  HeaderLocalIncludes(
      {HasBidirStreamingMethod()
           ? "google/cloud/async_streaming_read_write_rpc.h"
           : "",
       needs_completion_queue ? "google/cloud/completion_queue.h" : "",
       HasAsyncMethod() ? "google/cloud/future.h" : "",
       HasAsynchronousStreamingReadMethod()
           ? "google/cloud/internal/async_streaming_read_rpc.h"
           : "",
       HasAsynchronousStreamingWriteMethod()
           ? "google/cloud/internal/async_streaming_write_rpc.h"
           : "",
       HasStreamingReadMethod() ? "google/cloud/internal/streaming_read_rpc.h"
                                : "",
       HasStreamingWriteMethod() ? "google/cloud/internal/streaming_write_rpc.h"
                                 : "",
       "google/cloud/options.h", "google/cloud/status_or.h",
       "google/cloud/version.h"});
  std::vector<std::string> additional_pb_header_paths =
      absl::StrSplit(vars("additional_pb_header_paths"), absl::ByChar(','));
  HeaderSystemIncludes(additional_pb_header_paths);
  std::vector<std::string> mixin_headers =
      absl::StrSplit(vars("mixin_proto_grpc_header_paths"), ',');
  HeaderSystemIncludes(mixin_headers);
  HeaderSystemIncludes(
      {vars("proto_grpc_header_path"),
       HasLongrunningMethod() ? "google/longrunning/operations.grpc.pb.h" : "",
       "memory", "utility"});

  auto result = HeaderOpenNamespaces(NamespaceType::kInternal);
  if (!result.ok()) return result;

  // Abstract interface Stub base class
  HeaderPrint(  // clang-format off
    "\n"
    "class $stub_class_name$ {\n"
    " public:\n"
    "  virtual ~$stub_class_name$() = 0;\n");
  // clang-format on

  for (auto const& method : methods()) {
    if (IsStreamingWrite(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__,
                        R"""(
  virtual std::unique_ptr<::google::cloud::internal::StreamingWriteRpc<
      $request_type$,
      $response_type$>>
  $method_name$(
      std::shared_ptr<grpc::ClientContext> context,
      Options const& options) = 0;
)""");
      continue;
    }
    if (IsBidirStreaming(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__,
                        R"""(
  virtual std::unique_ptr<::google::cloud::AsyncStreamingReadWriteRpc<
      $request_type$,
      $response_type$>>
  Async$method_name$(
      google::cloud::CompletionQueue const& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options) = 0;
)""");
      continue;
    }
    if (IsLongrunningOperation(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual future<StatusOr<google::longrunning::Operation>> Async$method_name$(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options,
      $request_type$ const& request) = 0;
)""");
      HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual StatusOr<google::longrunning::Operation> $method_name$(
      grpc::ClientContext& context,
      Options options,
      $request_type$ const& request) = 0;
)""");
      continue;
    }
    if (IsStreamingRead(method)) {
      HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual std::unique_ptr<google::cloud::internal::StreamingReadRpc<$response_type$>>
  $method_name$(
    std::shared_ptr<grpc::ClientContext> context,
    Options const& options,
    $request_type$ const& request) = 0;
)""");
      continue;
    }
    HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual $return_type$ $method_name$(
      grpc::ClientContext& context,
      Options const& options,
      $request_type$ const& request) = 0;
)""");
  }

  for (auto const& method : async_methods()) {
    // Nothing to do, these are always asynchronous.
    if (IsBidirStreaming(method) || IsLongrunningOperation(method)) continue;
    if (IsStreamingRead(method)) {
      auto constexpr kDeclaration = R"""(
  virtual std::unique_ptr<::google::cloud::internal::AsyncStreamingReadRpc<
      $response_type$>>
  Async$method_name$(
      google::cloud::CompletionQueue const& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options,
      $request_type$ const& request) = 0;
)""";
      HeaderPrintMethod(method, __FILE__, __LINE__, kDeclaration);
      continue;
    }
    if (IsStreamingWrite(method)) {
      auto constexpr kDeclaration = R"""(
  virtual std::unique_ptr<::google::cloud::internal::AsyncStreamingWriteRpc<
      $request_type$, $response_type$>>
  Async$method_name$(
      google::cloud::CompletionQueue const& cq,
      std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options) = 0;
)""";
      HeaderPrintMethod(method, __FILE__, __LINE__, kDeclaration);
      continue;
    }
    HeaderPrintMethod(method, __FILE__, __LINE__, R"""(
  virtual future<$return_type$>
  Async$method_name$(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options,
    $request_type$ const& request) = 0;
)""");
  }

  // long running operation support methods
  if (HasLongrunningMethod()) {
    HeaderPrint(
        R"""(
  virtual future<StatusOr<google::longrunning::Operation>> AsyncGetOperation(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options,
      google::longrunning::GetOperationRequest const& request) = 0;

  virtual future<Status> AsyncCancelOperation(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions options,
      google::longrunning::CancelOperationRequest const& request) = 0;
)""");
  }
  // close abstract interface Stub base class
  HeaderPrint("};\n");

  // default stub class
  HeaderPrint(  // clang-format off
    "\n"
    "class Default$stub_class_name$ : public $stub_class_name$ {\n"
    " public:");
  std::unordered_map<std::string, std::string> mixin_grpc_stubs;
  for (auto const& mixin_method : MixinMethods()) {
    mixin_grpc_stubs[mixin_method.grpc_stub_name] = mixin_method.grpc_stub_fqn;
  }

  std::vector<std::string> mixin_stub_inputs_list;
  std::vector<std::string> mixin_stub_members_init_list;
  std::vector<std::string> mixin_stub_members_list;
  for (auto const& mixin_grpc_stub : mixin_grpc_stubs) {
    mixin_stub_inputs_list.push_back(absl::StrFormat(
      "std::unique_ptr<%s::StubInterface> %s", mixin_grpc_stub.second, mixin_grpc_stub.first));
    mixin_stub_members_init_list.push_back(absl::StrFormat(
      "%s_(std::move(%s))", mixin_grpc_stub.first, mixin_grpc_stub.first));
    mixin_stub_members_list.push_back(absl::StrFormat(
      "std::unique_ptr<%s::StubInterface> %s_;", mixin_grpc_stub.second, mixin_grpc_stub.first));
  }
  std::string const mixin_stub_inputs = absl::StrJoin(mixin_stub_inputs_list, ",\n");
  std::string const mixin_stub_members_init = absl::StrJoin(mixin_stub_members_init_list, ",\n");
  std::string const mixin_stub_members = absl::StrJoin(mixin_stub_members_list, "\n");

  if (HasLongrunningMethod()) {
    HeaderPrint(  // clang-format off
    absl::StrCat(R"""(
  Default$stub_class_name$(
      std::unique_ptr<$grpc_stub_fqn$::StubInterface> grpc_stub,
  )"""
      , mixin_stub_inputs, mixin_stub_inputs_list.empty() ? "" : ",\n",
R"""(    std::unique_ptr<google::longrunning::Operations::StubInterface> operations)
      : grpc_stub_(std::move(grpc_stub)),
)"""
      , mixin_stub_members_init, mixin_stub_members_init_list.empty() ? "" : ",\n",
R"""(        operations_(std::move(operations)) {}
)"""));
    // clang-format on
  } else {
    HeaderPrint(  // clang-format off
    absl::StrCat(R"""(
  explicit Default$stub_class_name$(
      std::unique_ptr<$grpc_stub_fqn$::StubInterface> grpc_stub)"""
      , mixin_stub_inputs_list.empty() ? "" : ",\n", mixin_stub_inputs,
      R"""()
      : grpc_stub_(std::move(grpc_stub)))"""
      , mixin_stub_members_init_list.empty() ? "" : ",\n", mixin_stub_members_init,
      R"""( {}
)"""));
    // clang-format on
  }

  HeaderPrintPublicMethods();

  // private members and close default stub class definition
  HeaderPrint(absl::StrCat(R"""(
 private:
  std::unique_ptr<$grpc_stub_fqn$::StubInterface> grpc_stub_;
)""",
                           mixin_stub_members));
  if (HasLongrunningMethod()) {
    HeaderPrint(  // clang-format off
    "  std::unique_ptr<google::longrunning::Operations::StubInterface> operations_;\n");
    // clang-format on
  }
  HeaderPrint("};\n");

  HeaderCloseNamespaces();
  // close header guard
  HeaderPrint("\n#endif  // $header_include_guard$\n");
  return {};
}

Status StubGenerator::GenerateCc() {
  CcPrint(CopyrightLicenseFileHeader());
  CcPrint(  // clang-format off
    "\n"
    "// Generated by the Codegen C++ plugin.\n"
    "// If you make any local changes, they will be lost.\n"
    "// source: $proto_file_name$\n");
  // clang-format on

  // includes
  CcPrint("\n");
  CcLocalIncludes(
      {vars("stub_header_path"),
       HasBidirStreamingMethod()
           ? "google/cloud/internal/async_read_write_stream_impl.h"
           : "",
       HasAsynchronousStreamingReadMethod()
           ? "google/cloud/internal/async_streaming_read_rpc_impl.h"
           : "",
       HasAsynchronousStreamingWriteMethod()
           ? "google/cloud/internal/async_streaming_write_rpc_impl.h"
           : "",
       HasStreamingWriteMethod()
           ? "google/cloud/internal/streaming_write_rpc_impl.h"
           : "",
       "google/cloud/grpc_error_delegate.h", "google/cloud/status_or.h"});
  CcSystemIncludes(
      {vars("proto_grpc_header_path"),
       HasLongrunningMethod() ? "google/longrunning/operations.grpc.pb.h" : "",
       "memory", "utility"});

  auto result = CcOpenNamespaces(NamespaceType::kInternal);
  if (!result.ok()) return result;

  CcPrint(  // clang-format off
    "\n"
    "$stub_class_name$::~$stub_class_name$() = default;\n");
  // clang-format on

  std::unordered_map<std::string, std::string> mixin_grpc_stubs;
  for (auto const& mixin_method : MixinMethods()) {
    mixin_grpc_stubs[mixin_method.method.get().name()] =
        mixin_method.grpc_stub_name;
  }

  // default stub class member methods
  for (auto const& method : methods()) {
    std::string const grpc_stub =
        mixin_grpc_stubs.find(method.get().name()) == mixin_grpc_stubs.end()
            ? "grpc_stub_"
            : mixin_grpc_stubs[method.get().name()] + "_";
    if (IsStreamingWrite(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    absl::StrFormat(R"""(
std::unique_ptr<::google::cloud::internal::StreamingWriteRpc<
    $request_type$,
    $response_type$>>
Default$stub_class_name$::$method_name$(
    std::shared_ptr<grpc::ClientContext> context,
    Options const&) {
  auto response = std::make_unique<$response_type$>();
  auto stream = %s->$method_name$(context.get(), response.get());
  return std::make_unique<::google::cloud::internal::StreamingWriteRpcImpl<
      $request_type$, $response_type$>>(
    std::move(context), std::move(response), std::move(stream));
}
)""",
                                    grpc_stub));
      continue;
    }
    if (IsBidirStreaming(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    absl::StrFormat(R"""(
std::unique_ptr<::google::cloud::AsyncStreamingReadWriteRpc<
    $request_type$,
    $response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue const& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options) {
  return google::cloud::internal::MakeStreamingReadWriteRpc<$request_type$, $response_type$>(
      cq, std::move(context), std::move(options),
      [this](grpc::ClientContext* context, grpc::CompletionQueue* cq) {
        return %s->PrepareAsync$method_name$(context, cq);
      });
}
)""",
                                    grpc_stub));
      continue;
    }
    if (IsLongrunningOperation(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    absl::StrFormat(R"""(
future<StatusOr<google::longrunning::Operation>>
Default$stub_class_name$::Async$method_name$(
      google::cloud::CompletionQueue& cq,
      std::shared_ptr<grpc::ClientContext> context,
      google::cloud::internal::ImmutableOptions,
      $request_type$ const& request) {
  return internal::MakeUnaryRpcImpl<$request_type$,
                                    google::longrunning::Operation>(
      cq,
      [this](grpc::ClientContext* context,
             $request_type$ const& request,
             grpc::CompletionQueue* cq) {
        return %s->Async$method_name$(context, request, cq);
      },
      request, std::move(context));
}
)""",
                                    grpc_stub));

      CcPrintMethod(method, __FILE__, __LINE__,
                    absl::StrFormat(R"""(
StatusOr<google::longrunning::Operation>
Default$stub_class_name$::$method_name$(
      grpc::ClientContext& context,
      Options,
      $request_type$ const& request) {
    $response_type$ response;
    auto status =
        %s->$method_name$(&context, request, &response);
    if (!status.ok()) {
      return google::cloud::MakeStatusFromRpcError(status);
    }
    return response;
}
)""",
                                    grpc_stub));

      continue;
    }
    if (IsStreamingRead(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    absl::StrFormat(R"""(
std::unique_ptr<google::cloud::internal::StreamingReadRpc<$response_type$>>
Default$stub_class_name$::$method_name$(
    std::shared_ptr<grpc::ClientContext> context,
    Options const&,
    $request_type$ const& request) {
  auto stream = %s->$method_name$(context.get(), request);
  return std::make_unique<google::cloud::internal::StreamingReadRpcImpl<
      $response_type$>>(
      std::move(context), std::move(stream));
}
)""",
                                    grpc_stub));
      continue;
    }

    if (IsResponseTypeEmpty(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    absl::StrFormat(R"""(
Status
Default$stub_class_name$::$method_name$(
  grpc::ClientContext& context, Options const&,
  $request_type$ const& request) {
    $response_type$ response;
    auto status =
        %s->$method_name$(&context, request, &response);
    if (!status.ok()) {
      return google::cloud::MakeStatusFromRpcError(status);
    }
    return google::cloud::Status();
}
)""",
                                    grpc_stub));
      continue;
    }
    CcPrintMethod(method, __FILE__, __LINE__,
                  absl::StrFormat(R"""(
StatusOr<$response_type$>
Default$stub_class_name$::$method_name$(
  grpc::ClientContext& context, Options const&,
  $request_type$ const& request) {
    $response_type$ response;
    auto status =
        %s->$method_name$(&context, request, &response);
    if (!status.ok()) {
      return google::cloud::MakeStatusFromRpcError(status);
    }
    return response;
}
)""",
                                  grpc_stub));
  }

  for (auto const& method : async_methods()) {
    // Nothing to do, these are always asynchronous.
    if (IsBidirStreaming(method) || IsLongrunningOperation(method)) continue;

    std::string const grpc_stub =
        mixin_grpc_stubs.find(method.get().name()) == mixin_grpc_stubs.end()
            ? "grpc_stub_"
            : mixin_grpc_stubs[method.get().name()] + "_";

    if (IsStreamingRead(method)) {
      auto const definition = absl::StrFormat(R"""(
std::unique_ptr<::google::cloud::internal::AsyncStreamingReadRpc<
    $response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue const& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options,
    $request_type$ const& request) {
  return google::cloud::internal::MakeStreamingReadRpc<$request_type$, $response_type$>(
    cq, std::move(context), std::move(options), request,
    [this](grpc::ClientContext* context, $request_type$ const& request, grpc::CompletionQueue* cq) {
      return %s->PrepareAsync$method_name$(context, request, cq);
    });
}
)""",
                                              grpc_stub);
      CcPrintMethod(method, __FILE__, __LINE__, definition);
      continue;
    }
    if (IsStreamingWrite(method)) {
      auto const definition = absl::StrFormat(R"""(
std::unique_ptr<::google::cloud::internal::AsyncStreamingWriteRpc<
    $request_type$, $response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue const& cq,
    std::shared_ptr<grpc::ClientContext> context,
    google::cloud::internal::ImmutableOptions options) {
  return google::cloud::internal::MakeStreamingWriteRpc<$request_type$, $response_type$>(
    cq, std::move(context), std::move(options),
    [this](grpc::ClientContext* context, $response_type$* response, grpc::CompletionQueue* cq) {
      return %s->PrepareAsync$method_name$(context, response, cq);
    });
}
)""",
                                              grpc_stub);
      CcPrintMethod(method, __FILE__, __LINE__, definition);
      continue;
    }
    if (IsResponseTypeEmpty(method)) {
      CcPrintMethod(method, __FILE__, __LINE__,
                    absl::StrFormat(R"""(
future<Status>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    $request_type$ const& request) {
  return internal::MakeUnaryRpcImpl<$request_type$,
                                    $response_type$>(
      cq,
      [this](grpc::ClientContext* context,
             $request_type$ const& request,
             grpc::CompletionQueue* cq) {
        return %s->Async$method_name$(context, request, cq);
      },
      request, std::move(context))
          .then([](future<StatusOr<google::protobuf::Empty>> f) {
            return f.get().status();
          });
}
)""",
                                    grpc_stub));
      continue;
    }
    CcPrintMethod(method, __FILE__, __LINE__,
                  absl::StrFormat(R"""(
future<StatusOr<$response_type$>>
Default$stub_class_name$::Async$method_name$(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    $request_type$ const& request) {
  return internal::MakeUnaryRpcImpl<$request_type$,
                                    $response_type$>(
      cq,
      [this](grpc::ClientContext* context,
             $request_type$ const& request,
             grpc::CompletionQueue* cq) {
        return %s->Async$method_name$(context, request, cq);
      },
      request, std::move(context));
}
)""",
                                  grpc_stub));
  }

  if (HasLongrunningMethod()) {
    CcPrint(R"""(
future<StatusOr<google::longrunning::Operation>>
Default$stub_class_name$::AsyncGetOperation(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    google::longrunning::GetOperationRequest const& request) {
  return internal::MakeUnaryRpcImpl<google::longrunning::GetOperationRequest,
                                    google::longrunning::Operation>(
      cq,
      [this](grpc::ClientContext* context,
             google::longrunning::GetOperationRequest const& request,
             grpc::CompletionQueue* cq) {
        return operations_->AsyncGetOperation(context, request, cq);
      },
      request, std::move(context));
}

future<Status> Default$stub_class_name$::AsyncCancelOperation(
    google::cloud::CompletionQueue& cq,
    std::shared_ptr<grpc::ClientContext> context,
    // NOLINTNEXTLINE(performance-unnecessary-value-param)
    google::cloud::internal::ImmutableOptions,
    google::longrunning::CancelOperationRequest const& request) {
  return internal::MakeUnaryRpcImpl<google::longrunning::CancelOperationRequest,
                                    google::protobuf::Empty>(
      cq,
      [this](grpc::ClientContext* context,
             google::longrunning::CancelOperationRequest const& request,
             grpc::CompletionQueue* cq) {
        return operations_->AsyncCancelOperation(context, request, cq);
      },
      request, std::move(context))
      .then([](future<StatusOr<google::protobuf::Empty>> f) {
        return f.get().status();
      });
}
)""");
  }

  CcCloseNamespaces();
  return {};
}

}  // namespace generator_internal
}  // namespace cloud
}  // namespace google
