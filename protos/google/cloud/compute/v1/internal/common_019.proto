// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the C++ microgenerator.
// If you make any local changes, they will be lost.
// file:///workspace/generator/discovery/compute_public_google_rest_v1.json
// revision: 20250302

syntax = "proto3";

package google.cloud.cpp.compute.v1;

import "google/cloud/compute/v1/internal/common_029.proto";
import "google/cloud/compute/v1/internal/common_078.proto";

// The specification for allowing client-side cross-origin requests. For more
// information about the W3C recommendation for cross-origin resource sharing
// (CORS), see Fetch API Living Standard.
message CorsPolicy {
  // In response to a preflight request, setting this to true indicates that the
  // actual request can include user credentials. This field translates to the
  // Access-Control-Allow-Credentials header. Default is false.
  optional bool allow_credentials = 1 [json_name = "allowCredentials"];

  // Specifies the content for the Access-Control-Allow-Headers header.
  repeated string allow_headers = 2 [json_name = "allowHeaders"];

  // Specifies the content for the Access-Control-Allow-Methods header.
  repeated string allow_methods = 3 [json_name = "allowMethods"];

  // Specifies a regular expression that matches allowed origins. For more
  // information, see regular expression syntax . An origin is allowed if it
  // matches either an item in allowOrigins or an item in allowOriginRegexes.
  // Regular expressions can only be used when the loadBalancingScheme is set to
  // INTERNAL_SELF_MANAGED.
  repeated string allow_origin_regexes = 4 [json_name = "allowOriginRegexes"];

  // Specifies the list of origins that is allowed to do CORS requests. An
  // origin is allowed if it matches either an item in allowOrigins or an item
  // in allowOriginRegexes.
  repeated string allow_origins = 5 [json_name = "allowOrigins"];

  // If true, disables the CORS policy. The default value is false, which
  // indicates that the CORS policy is in effect.
  optional bool disabled = 6 [json_name = "disabled"];

  // Specifies the content for the Access-Control-Expose-Headers header.
  repeated string expose_headers = 7 [json_name = "exposeHeaders"];

  // Specifies how long results of a preflight request can be cached in seconds.
  // This field translates to the Access-Control-Max-Age header.
  optional int32 max_age = 8 [json_name = "maxAge"];
}

// Specifies the custom error response policy that must be applied when the
// backend service or backend bucket responds with an error.
message CustomErrorResponsePolicy {
  // Specifies rules for returning error responses. In a given policy, if you
  // specify rules for both a range of error codes as well as rules for specific
  // error codes then rules with specific error codes have a higher priority.
  // For example, assume that you configure a rule for 401 (Un-authorized) code,
  // and another for all 4 series error codes (4XX). If the backend service
  // returns a 401, then the rule for 401 will be applied. However if the
  // backend service returns a 403, the rule for 4xx takes effect.
  repeated CustomErrorResponsePolicyCustomErrorResponseRule
      error_response_rules = 1 [json_name = "errorResponseRules"];

  // The full or partial URL to the BackendBucket resource that contains the
  // custom error content. Examples are: -
  // https://www.googleapis.com/compute/v1/projects/project/global/backendBuckets/myBackendBucket
  // - compute/v1/projects/project/global/backendBuckets/myBackendBucket -
  // global/backendBuckets/myBackendBucket If errorService is not specified at
  // lower levels like pathMatcher, pathRule and routeRule, an errorService
  // specified at a higher level in the UrlMap will be used. If
  // UrlMap.defaultCustomErrorResponsePolicy contains one or more
  // errorResponseRules[], it must specify errorService. If load balancer cannot
  // reach the backendBucket, a simple Not Found Error will be returned, with
  // the original response code (or overrideResponseCode if configured).
  // errorService is not supported for internal or regional HTTP/HTTPS load
  // balancers.
  optional string error_service = 2 [json_name = "errorService"];
}

// Specifies the mapping between the response code that will be returned along
// with the custom error content and the response code returned by the backend
// service.
message CustomErrorResponsePolicyCustomErrorResponseRule {
  // Valid values include: - A number between 400 and 599: For example 401 or
  // 503, in which case the load balancer applies the policy if the error code
  // exactly matches this value. - 5xx: Load Balancer will apply the policy if
  // the backend service responds with any response code in the range of 500 to
  // 599. - 4xx: Load Balancer will apply the policy if the backend service
  // responds with any response code in the range of 400 to 499. Values must be
  // unique within matchResponseCodes and across all errorResponseRules of
  // CustomErrorResponsePolicy.
  repeated string match_response_codes = 1 [json_name = "matchResponseCodes"];

  // The HTTP status code returned with the response containing the custom error
  // content. If overrideResponseCode is not supplied, the same response code
  // returned by the original backend bucket or backend service is returned to
  // the client.
  optional int32 override_response_code = 2
      [json_name = "overrideResponseCode"];

  // The full path to a file within backendBucket . For example:
  // /errors/defaultError.html path must start with a leading slash. path cannot
  // have trailing slashes. If the file is not available in backendBucket or the
  // load balancer cannot reach the BackendBucket, a simple Not Found Error is
  // returned to the client. The value must be from 1 to 1024 characters
  optional string path = 3 [json_name = "path"];
}

// UrlMaps A host-matching rule for a URL. If matched, will use the named
// PathMatcher to select the BackendService.
message HostRule {
  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 1 [json_name = "description"];

  // The list of host patterns to match. They must be valid hostnames with
  // optional port numbers in the format host:port. * matches any string of
  // ([a-z0-9-.]*). In that case, * must be the first character, and if followed
  // by anything, the immediate following character must be either - or .. *
  // based matching is not supported when the URL map is bound to a target gRPC
  // proxy that has the validateForProxyless field set to true.
  repeated string hosts = 2 [json_name = "hosts"];

  // The name of the PathMatcher to use to match the path portion of the URL if
  // the hostRule matches the URL's host portion.
  optional string path_matcher = 3 [json_name = "pathMatcher"];
}

// Specification for how requests are aborted as part of fault injection.
message HttpFaultAbort {
  // The HTTP status code used to abort the request. The value must be from 200
  // to 599 inclusive. For gRPC protocol, the gRPC status code is mapped to HTTP
  // status code according to this mapping table. HTTP status 200 is mapped to
  // gRPC status UNKNOWN. Injecting an OK status is currently not supported by
  // Traffic Director.
  optional uint32 http_status = 1 [json_name = "httpStatus"];

  // The percentage of traffic for connections, operations, or requests that is
  // aborted as part of fault injection. The value must be from 0.0 to 100.0
  // inclusive.
  optional double percentage = 2 [json_name = "percentage"];
}

// Specifies the delay introduced by the load balancer before forwarding the
// request to the backend service as part of fault injection.
message HttpFaultDelay {
  // Specifies the value of the fixed delay interval.
  optional Duration fixed_delay = 1 [json_name = "fixedDelay"];

  // The percentage of traffic for connections, operations, or requests for
  // which a delay is introduced as part of fault injection. The value must be
  // from 0.0 to 100.0 inclusive.
  optional double percentage = 2 [json_name = "percentage"];
}

// The specification for fault injection introduced into traffic to test the
// resiliency of clients to backend service failure. As part of fault injection,
// when clients send requests to a backend service, delays can be introduced by
// the load balancer on a percentage of requests before sending those request to
// the backend service. Similarly requests from clients can be aborted by the
// load balancer for a percentage of requests.
message HttpFaultInjection {
  // The specification for how client requests are aborted as part of fault
  // injection.
  optional HttpFaultAbort abort = 1 [json_name = "abort"];

  // The specification for how client requests are delayed as part of fault
  // injection, before being sent to a backend service.
  optional HttpFaultDelay delay = 2 [json_name = "delay"];
}

// The request and response header transformations that take effect before the
// request is passed along to the selected backendService.
message HttpHeaderAction {
  // Headers to add to a matching request before forwarding the request to the
  // backendService.
  repeated HttpHeaderOption request_headers_to_add = 1
      [json_name = "requestHeadersToAdd"];

  // A list of header names for headers that need to be removed from the request
  // before forwarding the request to the backendService.
  repeated string request_headers_to_remove = 2
      [json_name = "requestHeadersToRemove"];

  // Headers to add the response before sending the response back to the client.
  repeated HttpHeaderOption response_headers_to_add = 3
      [json_name = "responseHeadersToAdd"];

  // A list of header names for headers that need to be removed from the
  // response before sending the response back to the client.
  repeated string response_headers_to_remove = 4
      [json_name = "responseHeadersToRemove"];
}

// matchRule criteria for request header matches.
message HttpHeaderMatch {
  // The value should exactly match contents of exactMatch. Only one of
  // exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
  // rangeMatch must be set.
  optional string exact_match = 1 [json_name = "exactMatch"];

  // The name of the HTTP header to match. For matching against the HTTP
  // request's authority, use a headerMatch with the header name ":authority".
  // For matching a request's method, use the headerName ":method". When the URL
  // map is bound to a target gRPC proxy that has the validateForProxyless field
  // set to true, only non-binary user-specified custom metadata and the
  // `content-type` header are supported. The following transport-level headers
  // cannot be used in header matching rules: `:authority`, `:method`, `:path`,
  // `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`,
  // `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`,
  // `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
  optional string header_name = 2 [json_name = "headerName"];

  // If set to false, the headerMatch is considered a match if the preceding
  // match criteria are met. If set to true, the headerMatch is considered a
  // match if the preceding match criteria are NOT met. The default setting is
  // false.
  optional bool invert_match = 3 [json_name = "invertMatch"];

  // The value of the header must start with the contents of prefixMatch. Only
  // one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
  // rangeMatch must be set.
  optional string prefix_match = 4 [json_name = "prefixMatch"];

  // A header with the contents of headerName must exist. The match takes place
  // whether or not the request's header has a value. Only one of exactMatch,
  // prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be
  // set.
  optional bool present_match = 5 [json_name = "presentMatch"];

  // The header value must be an integer and its value must be in the range
  // specified in rangeMatch. If the header does not contain an integer, number
  // or is empty, the match fails. For example for a range [-5, 0] - -3 will
  // match. - 0 will not match. - 0.25 will not match. - -3someString will not
  // match. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
  // presentMatch or rangeMatch must be set. rangeMatch is not supported for
  // load balancers that have loadBalancingScheme set to EXTERNAL.
  optional Int64RangeMatch range_match = 6 [json_name = "rangeMatch"];

  // The value of the header must match the regular expression specified in
  // regexMatch. For more information about regular expression syntax, see
  // Syntax. For matching against a port specified in the HTTP request, use a
  // headerMatch with headerName set to PORT and a regular expression that
  // satisfies the RFC2616 Host header's port specifier. Only one of exactMatch,
  // prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be
  // set. Regular expressions can only be used when the loadBalancingScheme is
  // set to INTERNAL_SELF_MANAGED.
  optional string regex_match = 7 [json_name = "regexMatch"];

  // The value of the header must end with the contents of suffixMatch. Only one
  // of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
  // rangeMatch must be set.
  optional string suffix_match = 8 [json_name = "suffixMatch"];
}

// Specification determining how headers are added to requests or responses.
message HttpHeaderOption {
  // The name of the header.
  optional string header_name = 1 [json_name = "headerName"];

  // The value of the header to add.
  optional string header_value = 2 [json_name = "headerValue"];

  // If false, headerValue is appended to any values that already exist for the
  // header. If true, headerValue is set for the header, discarding any values
  // that were set for that header. The default value is false.
  optional bool replace = 3 [json_name = "replace"];
}

// HttpRouteRuleMatch criteria for a request's query parameter.
message HttpQueryParameterMatch {
  // The queryParameterMatch matches if the value of the parameter exactly
  // matches the contents of exactMatch. Only one of presentMatch, exactMatch,
  // or regexMatch must be set.
  optional string exact_match = 1 [json_name = "exactMatch"];

  // The name of the query parameter to match. The query parameter must exist in
  // the request, in the absence of which the request match fails.
  optional string name = 2 [json_name = "name"];

  // Specifies that the queryParameterMatch matches if the request contains the
  // query parameter, irrespective of whether the parameter has a value or not.
  // Only one of presentMatch, exactMatch, or regexMatch must be set.
  optional bool present_match = 3 [json_name = "presentMatch"];

  // The queryParameterMatch matches if the value of the parameter matches the
  // regular expression specified by regexMatch. For more information about
  // regular expression syntax, see Syntax. Only one of presentMatch,
  // exactMatch, or regexMatch must be set. Regular expressions can only be used
  // when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
  optional string regex_match = 4 [json_name = "regexMatch"];
}

// Specifies settings for an HTTP redirect.
message HttpRedirectAction {
  // The host that is used in the redirect response instead of the one that was
  // supplied in the request. The value must be from 1 to 255 characters.
  optional string host_redirect = 1 [json_name = "hostRedirect"];

  // If set to true, the URL scheme in the redirected request is set to HTTPS.
  // If set to false, the URL scheme of the redirected request remains the same
  // as that of the request. This must only be set for URL maps used in
  // TargetHttpProxys. Setting this true for TargetHttpsProxy is not permitted.
  // The default is set to false.
  optional bool https_redirect = 2 [json_name = "httpsRedirect"];

  // The path that is used in the redirect response instead of the one that was
  // supplied in the request. pathRedirect cannot be supplied together with
  // prefixRedirect. Supply one alone or neither. If neither is supplied, the
  // path of the original request is used for the redirect. The value must be
  // from 1 to 1024 characters.
  optional string path_redirect = 3 [json_name = "pathRedirect"];

  // The prefix that replaces the prefixMatch specified in the
  // HttpRouteRuleMatch, retaining the remaining portion of the URL before
  // redirecting the request. prefixRedirect cannot be supplied together with
  // pathRedirect. Supply one alone or neither. If neither is supplied, the path
  // of the original request is used for the redirect. The value must be from 1
  // to 1024 characters.
  optional string prefix_redirect = 4 [json_name = "prefixRedirect"];

  // The HTTP Status code to use for this RedirectAction. Supported values are:
  // - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to
  // 301. - FOUND, which corresponds to 302. - SEE_OTHER which corresponds to
  // 303. - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the
  // request method is retained. - PERMANENT_REDIRECT, which corresponds to 308.
  // In this case, the request method is retained.
  // FOUND: Http Status Code 302 - Found.
  // MOVED_PERMANENTLY_DEFAULT: Http Status Code 301 - Moved Permanently.
  // PERMANENT_REDIRECT: Http Status Code 308 - Permanent Redirect maintaining
  // HTTP method.
  // SEE_OTHER: Http Status Code 303 - See Other.
  // TEMPORARY_REDIRECT: Http Status Code 307 - Temporary Redirect maintaining
  // HTTP method.
  optional string redirect_response_code = 5
      [json_name = "redirectResponseCode"];

  // If set to true, any accompanying query portion of the original URL is
  // removed before redirecting the request. If set to false, the query portion
  // of the original URL is retained. The default is set to false.
  optional bool strip_query = 6 [json_name = "stripQuery"];
}

// The retry policy associates with HttpRouteRule
message HttpRetryPolicy {
  // Specifies the allowed number retries. This number must be > 0. If not
  // specified, defaults to 1.
  optional uint32 num_retries = 1 [json_name = "numRetries"];

  // Specifies a non-zero timeout per retry attempt. If not specified, will use
  // the timeout set in the HttpRouteAction field. If timeout in the
  // HttpRouteAction field is not set, this field uses the largest timeout among
  // all backend services associated with the route. Not supported when the URL
  // map is bound to a target gRPC proxy that has the validateForProxyless field
  // set to true.
  optional Duration per_try_timeout = 2 [json_name = "perTryTimeout"];

  // Specifies one or more conditions when this retry policy applies. Valid
  // values are: - 5xx: retry is attempted if the instance or endpoint responds
  // with any 5xx response code, or if the instance or endpoint does not respond
  // at all. For example, disconnects, reset, read timeout, connection failure,
  // and refused streams. - gateway-error: Similar to 5xx, but only applies to
  // response codes 502, 503 or 504. - connect-failure: a retry is attempted on
  // failures connecting to the instance or endpoint. For example, connection
  // timeouts. - retriable-4xx: a retry is attempted if the instance or endpoint
  // responds with a 4xx response code. The only error that you can retry is
  // error code 409. - refused-stream: a retry is attempted if the instance or
  // endpoint resets the stream with a REFUSED_STREAM error code. This reset
  // type indicates that it is safe to retry. - cancelled: a retry is attempted
  // if the gRPC status code in the response header is set to cancelled. -
  // deadline-exceeded: a retry is attempted if the gRPC status code in the
  // response header is set to deadline-exceeded. - internal: a retry is
  // attempted if the gRPC status code in the response header is set to
  // internal. - resource-exhausted: a retry is attempted if the gRPC status
  // code in the response header is set to resource-exhausted. - unavailable: a
  // retry is attempted if the gRPC status code in the response header is set to
  // unavailable. Only the following codes are supported when the URL map is
  // bound to target gRPC proxy that has validateForProxyless field set to true.
  // - cancelled - deadline-exceeded - internal - resource-exhausted -
  // unavailable
  repeated string retry_conditions = 3 [json_name = "retryConditions"];
}

message HttpRouteAction {
  // The specification for allowing client-side cross-origin requests. For more
  // information about the W3C recommendation for cross-origin resource sharing
  // (CORS), see Fetch API Living Standard. Not supported when the URL map is
  // bound to a target gRPC proxy.
  optional CorsPolicy cors_policy = 1 [json_name = "corsPolicy"];

  // The specification for fault injection introduced into traffic to test the
  // resiliency of clients to backend service failure. As part of fault
  // injection, when clients send requests to a backend service, delays can be
  // introduced by a load balancer on a percentage of requests before sending
  // those requests to the backend service. Similarly requests from clients can
  // be aborted by the load balancer for a percentage of requests. timeout and
  // retry_policy is ignored by clients that are configured with a
  // fault_injection_policy if: 1. The traffic is generated by fault injection
  // AND 2. The fault injection is not a delay fault injection. Fault injection
  // is not supported with the classic Application Load Balancer . To see which
  // load balancers support fault injection, see Load balancing: Routing and
  // traffic management features.
  optional HttpFaultInjection fault_injection_policy = 2
      [json_name = "faultInjectionPolicy"];

  // Specifies the maximum duration (timeout) for streams on the selected route.
  // Unlike the timeout field where the timeout duration starts from the time
  // the request has been fully processed (known as *end-of-stream*), the
  // duration in this field is computed from the beginning of the stream until
  // the response has been processed, including all retries. A stream that does
  // not complete in this duration is closed. If not specified, this field uses
  // the maximum maxStreamDuration value among all backend services associated
  // with the route. This field is only allowed if the Url map is used with
  // backend services with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  optional Duration max_stream_duration = 3 [json_name = "maxStreamDuration"];

  // Specifies the policy on how requests intended for the route's backends are
  // shadowed to a separate mirrored backend service. The load balancer does not
  // wait for responses from the shadow service. Before sending traffic to the
  // shadow service, the host / authority header is suffixed with -shadow. Not
  // supported when the URL map is bound to a target gRPC proxy that has the
  // validateForProxyless field set to true.
  optional RequestMirrorPolicy request_mirror_policy = 4
      [json_name = "requestMirrorPolicy"];

  // Specifies the retry policy associated with this route.
  optional HttpRetryPolicy retry_policy = 5 [json_name = "retryPolicy"];

  // Specifies the timeout for the selected route. Timeout is computed from the
  // time the request has been fully processed (known as *end-of-stream*) up
  // until the response has been processed. Timeout includes all retries. If not
  // specified, this field uses the largest timeout among all backend services
  // associated with the route. Not supported when the URL map is bound to a
  // target gRPC proxy that has validateForProxyless field set to true.
  optional Duration timeout = 6 [json_name = "timeout"];

  // The spec to modify the URL of the request, before forwarding the request to
  // the matched service. urlRewrite is the only action supported in UrlMaps for
  // classic Application Load Balancers. Not supported when the URL map is bound
  // to a target gRPC proxy that has the validateForProxyless field set to true.
  optional UrlRewrite url_rewrite = 7 [json_name = "urlRewrite"];

  // A list of weighted backend services to send traffic to when a route match
  // occurs. The weights determine the fraction of traffic that flows to their
  // corresponding backend service. If all traffic needs to go to a single
  // backend service, there must be one weightedBackendService with weight set
  // to a non-zero number. After a backend service is identified and before
  // forwarding the request to the backend service, advanced routing actions
  // such as URL rewrites and header transformations are applied depending on
  // additional settings specified in this HttpRouteAction.
  repeated WeightedBackendService weighted_backend_services = 8
      [json_name = "weightedBackendServices"];
}

// The HttpRouteRule setting specifies how to match an HTTP request and the
// corresponding routing action that load balancing proxies perform.
message HttpRouteRule {
  // customErrorResponsePolicy specifies how the Load Balancer returns error
  // responses when BackendServiceor BackendBucket responds with an error. If a
  // policy for an error code is not configured for the RouteRule, a policy for
  // the error code configured in pathMatcher.defaultCustomErrorResponsePolicy
  // is applied. If one is not specified in
  // pathMatcher.defaultCustomErrorResponsePolicy, the policy configured in
  // UrlMap.defaultCustomErrorResponsePolicy takes effect. For example, consider
  // a UrlMap with the following configuration: -
  // UrlMap.defaultCustomErrorResponsePolicy are configured with policies for
  // 5xx and 4xx errors - A RouteRule for /coming_soon/ is configured for the
  // error code 404. If the request is for www.myotherdomain.com and a 404 is
  // encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes
  // effect. If a 404 response is encountered for the request
  // www.example.com/current_events/, the pathMatcher's policy takes effect. If
  // however, the request for www.example.com/coming_soon/ encounters a 404, the
  // policy in RouteRule.customErrorResponsePolicy takes effect. If any of the
  // requests in this example encounter a 500 error code, the policy at
  // UrlMap.defaultCustomErrorResponsePolicy takes effect. When used in
  // conjunction with routeRules.routeAction.retryPolicy, retries take
  // precedence. Only once all retries are exhausted, the
  // customErrorResponsePolicy is applied. While attempting a retry, if load
  // balancer is successful in reaching the service, the
  // customErrorResponsePolicy is ignored and the response from the service is
  // returned to the client. customErrorResponsePolicy is supported only for
  // global external Application Load Balancers.
  optional CustomErrorResponsePolicy custom_error_response_policy = 8
      [json_name = "customErrorResponsePolicy"];

  // The short description conveying the intent of this routeRule. The
  // description can have a maximum length of 1024 characters.
  optional string description = 1 [json_name = "description"];

  // Specifies changes to request and response headers that need to take effect
  // for the selected backendService. The headerAction value specified here is
  // applied before the matching pathMatchers[].headerAction and after
  // pathMatchers[].routeRules[].routeAction.weightedBackendService.backendServiceWeightAction[].headerAction
  // HeaderAction is not supported for load balancers that have their
  // loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
  // bound to a target gRPC proxy that has validateForProxyless field set to
  // true.
  optional HttpHeaderAction header_action = 2 [json_name = "headerAction"];

  // The list of criteria for matching attributes of a request to this
  // routeRule. This list has OR semantics: the request matches this routeRule
  // when any of the matchRules are satisfied. However predicates within a given
  // matchRule have AND semantics. All predicates within a matchRule must match
  // for the request to match the rule.
  repeated HttpRouteRuleMatch match_rules = 3 [json_name = "matchRules"];

  // For routeRules within a given pathMatcher, priority determines the order in
  // which a load balancer interprets routeRules. RouteRules are evaluated in
  // order of priority, from the lowest to highest number. The priority of a
  // rule decreases as its number increases (1, 2, 3, N+1). The first rule that
  // matches the request is applied. You cannot configure two or more routeRules
  // with the same priority. Priority for each rule must be set to a number from
  // 0 to 2147483647 inclusive. Priority numbers can have gaps, which enable you
  // to add or remove rules in the future without affecting the rest of the
  // rules. For example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority
  // numbers to which you could add rules numbered from 6 to 8, 10 to 11, and 13
  // to 15 in the future without any impact on existing rules.
  optional int32 priority = 4 [json_name = "priority"];

  // In response to a matching matchRule, the load balancer performs advanced
  // routing actions, such as URL rewrites and header transformations, before
  // forwarding the request to the selected backend. Only one of urlRedirect,
  // service or routeAction.weightedBackendService can be set. URL maps for
  // classic Application Load Balancers only support the urlRewrite action
  // within a route rule's routeAction.
  optional HttpRouteAction route_action = 5 [json_name = "routeAction"];

  // The full or partial URL of the backend service resource to which traffic is
  // directed if this rule is matched. If routeAction is also specified,
  // advanced routing actions, such as URL rewrites, take effect before sending
  // the request to the backend. Only one of urlRedirect, service or
  // routeAction.weightedBackendService can be set.
  optional string service = 6 [json_name = "service"];

  // When this rule is matched, the request is redirected to a URL specified by
  // urlRedirect. Only one of urlRedirect, service or
  // routeAction.weightedBackendService can be set. Not supported when the URL
  // map is bound to a target gRPC proxy.
  optional HttpRedirectAction url_redirect = 7 [json_name = "urlRedirect"];
}

// HttpRouteRuleMatch specifies a set of criteria for matching requests to an
// HttpRouteRule. All specified criteria must be satisfied for a match to occur.
message HttpRouteRuleMatch {
  // For satisfying the matchRule condition, the path of the request must
  // exactly match the value specified in fullPathMatch after removing any query
  // parameters and anchor that may be part of the original URL. fullPathMatch
  // must be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch
  // or regexMatch must be specified.
  optional string full_path_match = 1 [json_name = "fullPathMatch"];

  // Specifies a list of header match criteria, all of which must match
  // corresponding headers in the request.
  repeated HttpHeaderMatch header_matches = 2 [json_name = "headerMatches"];

  // Specifies that prefixMatch and fullPathMatch matches are case sensitive.
  // The default value is false. ignoreCase must not be used with regexMatch.
  // Not supported when the URL map is bound to a target gRPC proxy.
  optional bool ignore_case = 3 [json_name = "ignoreCase"];

  // Opaque filter criteria used by the load balancer to restrict routing
  // configuration to a limited set of xDS compliant clients. In their xDS
  // requests to the load balancer, xDS clients present node metadata. When
  // there is a match, the relevant routing configuration is made available to
  // those proxies. For each metadataFilter in this list, if its
  // filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels
  // must match the corresponding label provided in the metadata. If its
  // filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must
  // match with corresponding labels provided in the metadata. If multiple
  // metadata filters are specified, all of them need to be satisfied in order
  // to be considered a match. metadataFilters specified here is applied after
  // those specified in ForwardingRule that refers to the UrlMap this
  // HttpRouteRuleMatch belongs to. metadataFilters only applies to load
  // balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED. Not
  // supported when the URL map is bound to a target gRPC proxy that has
  // validateForProxyless field set to true.
  repeated MetadataFilter metadata_filters = 4 [json_name = "metadataFilters"];

  // If specified, the route is a pattern match expression that must match the
  // :path header once the query string is removed. A pattern match allows you
  // to match - The value must be between 1 and 1024 characters - The pattern
  // must start with a leading slash ("/") - There may be no more than 5
  // operators in pattern Precisely one of prefix_match, full_path_match,
  // regex_match or path_template_match must be set.
  optional string path_template_match = 8 [json_name = "pathTemplateMatch"];

  // For satisfying the matchRule condition, the request's path must begin with
  // the specified prefixMatch. prefixMatch must begin with a /. The value must
  // be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch or
  // regexMatch must be specified.
  optional string prefix_match = 5 [json_name = "prefixMatch"];

  // Specifies a list of query parameter match criteria, all of which must match
  // corresponding query parameters in the request. Not supported when the URL
  // map is bound to a target gRPC proxy.
  repeated HttpQueryParameterMatch query_parameter_matches = 6
      [json_name = "queryParameterMatches"];

  // For satisfying the matchRule condition, the path of the request must
  // satisfy the regular expression specified in regexMatch after removing any
  // query parameters and anchor supplied with the original URL. For more
  // information about regular expression syntax, see Syntax. Only one of
  // prefixMatch, fullPathMatch or regexMatch must be specified. Regular
  // expressions can only be used when the loadBalancingScheme is set to
  // INTERNAL_SELF_MANAGED.
  optional string regex_match = 7 [json_name = "regexMatch"];
}

// HttpRouteRuleMatch criteria for field values that must stay within the
// specified integer range.
message Int64RangeMatch {
  // The end of the range (exclusive) in signed long integer format.
  optional string range_end = 1 [json_name = "rangeEnd"];

  // The start of the range (inclusive) in signed long integer format.
  optional string range_start = 2 [json_name = "rangeStart"];
}

// A matcher for the path portion of the URL. The BackendService from the
// longest-matched rule will serve the URL. If no rule was matched, the default
// service is used.
message PathMatcher {
  // defaultCustomErrorResponsePolicy specifies how the Load Balancer returns
  // error responses when BackendServiceor BackendBucket responds with an error.
  // This policy takes effect at the PathMatcher level and applies only when no
  // policy has been defined for the error code at lower levels like RouteRule
  // and PathRule within this PathMatcher. If an error code does not have a
  // policy defined in defaultCustomErrorResponsePolicy, then a policy defined
  // for the error code in UrlMap.defaultCustomErrorResponsePolicy takes effect.
  // For example, consider a UrlMap with the following configuration: -
  // UrlMap.defaultCustomErrorResponsePolicy is configured with policies for 5xx
  // and 4xx errors - A RouteRule for /coming_soon/ is configured for the error
  // code 404. If the request is for www.myotherdomain.com and a 404 is
  // encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes
  // effect. If a 404 response is encountered for the request
  // www.example.com/current_events/, the pathMatcher's policy takes effect. If
  // however, the request for www.example.com/coming_soon/ encounters a 404, the
  // policy in RouteRule.customErrorResponsePolicy takes effect. If any of the
  // requests in this example encounter a 500 error code, the policy at
  // UrlMap.defaultCustomErrorResponsePolicy takes effect. When used in
  // conjunction with pathMatcher.defaultRouteAction.retryPolicy, retries take
  // precedence. Only once all retries are exhausted, the
  // defaultCustomErrorResponsePolicy is applied. While attempting a retry, if
  // load balancer is successful in reaching the service, the
  // defaultCustomErrorResponsePolicy is ignored and the response from the
  // service is returned to the client. defaultCustomErrorResponsePolicy is
  // supported only for global external Application Load Balancers.
  optional CustomErrorResponsePolicy default_custom_error_response_policy = 9
      [json_name = "defaultCustomErrorResponsePolicy"];

  // defaultRouteAction takes effect when none of the pathRules or routeRules
  // match. The load balancer performs advanced routing actions, such as URL
  // rewrites and header transformations, before forwarding the request to the
  // selected backend. Only one of defaultUrlRedirect, defaultService or
  // defaultRouteAction.weightedBackendService can be set. URL maps for classic
  // Application Load Balancers only support the urlRewrite action within a path
  // matcher's defaultRouteAction.
  optional HttpRouteAction default_route_action = 1
      [json_name = "defaultRouteAction"];

  // The full or partial URL to the BackendService resource. This URL is used if
  // none of the pathRules or routeRules defined by this PathMatcher are
  // matched. For example, the following are all valid URLs to a BackendService
  // resource: - https://www.googleapis.com/compute/v1/projects/project
  // /global/backendServices/backendService -
  // compute/v1/projects/project/global/backendServices/backendService -
  // global/backendServices/backendService If defaultRouteAction is also
  // specified, advanced routing actions, such as URL rewrites, take effect
  // before sending the request to the backend. Only one of defaultUrlRedirect,
  // defaultService or defaultRouteAction.weightedBackendService can be set.
  // Authorization requires one or more of the following Google IAM permissions
  // on the specified resource default_service: - compute.backendBuckets.use -
  // compute.backendServices.use
  optional string default_service = 2 [json_name = "defaultService"];

  // When none of the specified pathRules or routeRules match, the request is
  // redirected to a URL specified by defaultUrlRedirect. Only one of
  // defaultUrlRedirect, defaultService or
  // defaultRouteAction.weightedBackendService can be set. Not supported when
  // the URL map is bound to a target gRPC proxy.
  optional HttpRedirectAction default_url_redirect = 3
      [json_name = "defaultUrlRedirect"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 4 [json_name = "description"];

  // [Output Only] Commitment end time in RFC3339 text format.
  optional string end_timestamp = 5 [json_name = "endTimestamp"];

  // The name to which this PathMatcher is referred by the HostRule.
  optional string name = 6 [json_name = "name"];

  // The list of path rules. Use this list instead of routeRules when routing
  // based on simple path matching is all that's required. The order by which
  // path rules are specified does not matter. Matches are always done on the
  // longest-path-first basis. For example: a pathRule with a path /a/b/c/* will
  // match before /a/b/* irrespective of the order in which those paths appear
  // in this list. Within a given pathMatcher, only one of pathRules or
  // routeRules must be set.
  repeated PathRule path_rules = 7 [json_name = "pathRules"];

  // The list of HTTP route rules. Use this list instead of pathRules when
  // advanced route matching and routing actions are desired. routeRules are
  // evaluated in order of priority, from the lowest to highest number. Within a
  // given pathMatcher, you can set only one of pathRules or routeRules.
  repeated HttpRouteRule route_rules = 8 [json_name = "routeRules"];
}

// A path-matching rule for a URL. If matched, will use the specified
// BackendService to handle the traffic arriving at this URL.
message PathRule {
  // customErrorResponsePolicy specifies how the Load Balancer returns error
  // responses when BackendServiceor BackendBucket responds with an error. If a
  // policy for an error code is not configured for the PathRule, a policy for
  // the error code configured in pathMatcher.defaultCustomErrorResponsePolicy
  // is applied. If one is not specified in
  // pathMatcher.defaultCustomErrorResponsePolicy, the policy configured in
  // UrlMap.defaultCustomErrorResponsePolicy takes effect. For example, consider
  // a UrlMap with the following configuration: -
  // UrlMap.defaultCustomErrorResponsePolicy are configured with policies for
  // 5xx and 4xx errors - A PathRule for /coming_soon/ is configured for the
  // error code 404. If the request is for www.myotherdomain.com and a 404 is
  // encountered, the policy under UrlMap.defaultCustomErrorResponsePolicy takes
  // effect. If a 404 response is encountered for the request
  // www.example.com/current_events/, the pathMatcher's policy takes effect. If
  // however, the request for www.example.com/coming_soon/ encounters a 404, the
  // policy in PathRule.customErrorResponsePolicy takes effect. If any of the
  // requests in this example encounter a 500 error code, the policy at
  // UrlMap.defaultCustomErrorResponsePolicy takes effect.
  // customErrorResponsePolicy is supported only for global external Application
  // Load Balancers.
  optional CustomErrorResponsePolicy custom_error_response_policy = 5
      [json_name = "customErrorResponsePolicy"];

  // The list of path patterns to match. Each must start with / and the only
  // place a * is allowed is at the end following a /. The string fed to the
  // path matcher does not include any text after the first ? or #, and those
  // chars are not allowed here.
  repeated string paths = 1 [json_name = "paths"];

  // In response to a matching path, the load balancer performs advanced routing
  // actions, such as URL rewrites and header transformations, before forwarding
  // the request to the selected backend. Only one of urlRedirect, service or
  // routeAction.weightedBackendService can be set. URL maps for classic
  // Application Load Balancers only support the urlRewrite action within a path
  // rule's routeAction.
  optional HttpRouteAction route_action = 2 [json_name = "routeAction"];

  // The full or partial URL of the backend service resource to which traffic is
  // directed if this rule is matched. If routeAction is also specified,
  // advanced routing actions, such as URL rewrites, take effect before sending
  // the request to the backend. Only one of urlRedirect, service or
  // routeAction.weightedBackendService can be set.
  optional string service = 3 [json_name = "service"];

  // When a path pattern is matched, the request is redirected to a URL
  // specified by urlRedirect. Only one of urlRedirect, service or
  // routeAction.weightedBackendService can be set. Not supported when the URL
  // map is bound to a target gRPC proxy.
  optional HttpRedirectAction url_redirect = 4 [json_name = "urlRedirect"];
}

// A policy that specifies how requests intended for the route's backends are
// shadowed to a separate mirrored backend service. The load balancer doesn't
// wait for responses from the shadow service. Before sending traffic to the
// shadow service, the host or authority header is suffixed with -shadow.
message RequestMirrorPolicy {
  // The full or partial URL to the BackendService resource being mirrored to.
  // The backend service configured for a mirroring policy must reference
  // backends that are of the same type as the original backend service matched
  // in the URL map. Serverless NEG backends are not currently supported as a
  // mirrored backend service.
  optional string backend_service = 1 [json_name = "backendService"];
}

message TestFailure {
  // The actual output URL evaluated by a load balancer containing the scheme,
  // host, path and query parameters.
  optional string actual_output_url = 1 [json_name = "actualOutputUrl"];

  // Actual HTTP status code for rule with `urlRedirect` calculated by load
  // balancer
  optional int32 actual_redirect_response_code = 2
      [json_name = "actualRedirectResponseCode"];

  // BackendService or BackendBucket returned by load balancer.
  optional string actual_service = 3 [json_name = "actualService"];

  // The expected output URL evaluated by a load balancer containing the scheme,
  // host, path and query parameters.
  optional string expected_output_url = 4 [json_name = "expectedOutputUrl"];

  // Expected HTTP status code for rule with `urlRedirect` calculated by load
  // balancer
  optional int32 expected_redirect_response_code = 5
      [json_name = "expectedRedirectResponseCode"];

  // Expected BackendService or BackendBucket resource the given URL should be
  // mapped to.
  optional string expected_service = 6 [json_name = "expectedService"];

  // HTTP headers of the request.
  repeated UrlMapTestHeader headers = 7 [json_name = "headers"];

  // Host portion of the URL.
  optional string host = 8 [json_name = "host"];

  // Path portion including query parameters in the URL.
  optional string path = 9 [json_name = "path"];
}

// Represents a URL Map resource. Compute Engine has two URL Map resources: *
// [Global](/compute/docs/reference/rest/v1/urlMaps) *
// [Regional](/compute/docs/reference/rest/v1/regionUrlMaps) A URL map resource
// is a component of certain types of cloud load balancers and Traffic Director:
// * urlMaps are used by global external Application Load Balancers, classic
// Application Load Balancers, and cross-region internal Application Load
// Balancers. * regionUrlMaps are used by internal Application Load Balancers,
// regional external Application Load Balancers and regional internal
// Application Load Balancers. For a list of supported URL map features by the
// load balancer type, see the Load balancing features: Routing and traffic
// management table. For a list of supported URL map features for Traffic
// Director, see the Traffic Director features: Routing and traffic management
// table. This resource defines mappings from hostnames and URL paths to either
// a backend service or a backend bucket. To use the global urlMaps resource,
// the backend service must have a loadBalancingScheme of either EXTERNAL,
// EXTERNAL_MANAGED, or INTERNAL_SELF_MANAGED. To use the regionUrlMaps
// resource, the backend service must have a loadBalancingScheme of
// INTERNAL_MANAGED. For more information, read URL Map Concepts.
message UrlMap {
  // [Output Only] Creation timestamp in RFC3339 text format.
  optional string creation_timestamp = 1 [json_name = "creationTimestamp"];

  // defaultCustomErrorResponsePolicy specifies how the Load Balancer returns
  // error responses when BackendServiceor BackendBucket responds with an error.
  // This policy takes effect at the load balancer level and applies only when
  // no policy has been defined for the error code at lower levels like
  // PathMatcher, RouteRule and PathRule within this UrlMap. For example,
  // consider a UrlMap with the following configuration: -
  // defaultCustomErrorResponsePolicy containing policies for responding to 5xx
  // and 4xx errors - A PathMatcher configured for *.example.com has
  // defaultCustomErrorResponsePolicy for 4xx. If a request for
  // http://www.example.com/ encounters a 404, the policy in
  // pathMatcher.defaultCustomErrorResponsePolicy will be enforced. When the
  // request for http://www.example.com/ encounters a 502, the policy in
  // UrlMap.defaultCustomErrorResponsePolicy will be enforced. When a request
  // that does not match any host in *.example.com such as
  // http://www.myotherexample.com/, encounters a 404,
  // UrlMap.defaultCustomErrorResponsePolicy takes effect. When used in
  // conjunction with defaultRouteAction.retryPolicy, retries take precedence.
  // Only once all retries are exhausted, the defaultCustomErrorResponsePolicy
  // is applied. While attempting a retry, if load balancer is successful in
  // reaching the service, the defaultCustomErrorResponsePolicy is ignored and
  // the response from the service is returned to the client.
  // defaultCustomErrorResponsePolicy is supported only for global external
  // Application Load Balancers.
  optional CustomErrorResponsePolicy default_custom_error_response_policy = 16
      [json_name = "defaultCustomErrorResponsePolicy"];

  // defaultRouteAction takes effect when none of the hostRules match. The load
  // balancer performs advanced routing actions, such as URL rewrites and header
  // transformations, before forwarding the request to the selected backend.
  // Only one of defaultUrlRedirect, defaultService or
  // defaultRouteAction.weightedBackendService can be set. URL maps for classic
  // Application Load Balancers only support the urlRewrite action within
  // defaultRouteAction. defaultRouteAction has no effect when the URL map is
  // bound to a target gRPC proxy that has the validateForProxyless field set to
  // true.
  optional HttpRouteAction default_route_action = 2
      [json_name = "defaultRouteAction"];

  // The full or partial URL of the defaultService resource to which traffic is
  // directed if none of the hostRules match. If defaultRouteAction is also
  // specified, advanced routing actions, such as URL rewrites, take effect
  // before sending the request to the backend. Only one of defaultUrlRedirect,
  // defaultService or defaultRouteAction.weightedBackendService can be set.
  // defaultService has no effect when the URL map is bound to a target gRPC
  // proxy that has the validateForProxyless field set to true.
  optional string default_service = 3 [json_name = "defaultService"];

  // When none of the specified hostRules match, the request is redirected to a
  // URL specified by defaultUrlRedirect. Only one of defaultUrlRedirect,
  // defaultService or defaultRouteAction.weightedBackendService can be set. Not
  // supported when the URL map is bound to a target gRPC proxy.
  optional HttpRedirectAction default_url_redirect = 4
      [json_name = "defaultUrlRedirect"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 5 [json_name = "description"];

  // Fingerprint of this resource. A hash of the contents stored in this object.
  // This field is used in optimistic locking. This field is ignored when
  // inserting a UrlMap. An up-to-date fingerprint must be provided in order to
  // update the UrlMap, otherwise the request will fail with error 412
  // conditionNotMet. To see the latest fingerprint, make a get() request to
  // retrieve a UrlMap.
  optional string fingerprint = 6 [json_name = "fingerprint"];

  // Specifies changes to request and response headers that need to take effect
  // for the selected backendService. The headerAction specified here take
  // effect after headerAction specified under pathMatcher. headerAction is not
  // supported for load balancers that have their loadBalancingScheme set to
  // EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy
  // that has validateForProxyless field set to true.
  optional HttpHeaderAction header_action = 7 [json_name = "headerAction"];

  // The list of host rules to use against the URL.
  repeated HostRule host_rules = 8 [json_name = "hostRules"];

  // [Output Only] The unique identifier for the resource. This identifier is
  // defined by the server.
  optional string id = 6 [json_name = "id"];

  // [Output Only] Type of the resource. Always compute#commitment for
  // commitments.
  optional string kind = 7 [json_name = "kind"];

  // The license specification required as part of a license commitment.
  optional LicenseResourceCommitment license_resource = 8
      [json_name = "licenseResource"];

  // List of source commitments to be merged into a new commitment.
  repeated string merge_source_commitments = 9
      [json_name = "mergeSourceCommitments"];

  // Name of the resource. Provided by the client when the resource is created.
  // The name must be 1-63 characters long, and comply with RFC1035.
  // Specifically, the name must be 1-63 characters long and match the regular
  // expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  // must be a lowercase letter, and all following characters must be a dash,
  // lowercase letter, or digit, except the last character, which cannot be a
  // dash.
  optional string name = 10 [json_name = "name"];

  // The plan for this commitment, which determines duration and discount rate.
  // The currently supported plans are TWELVE_MONTH (1 year), and
  // THIRTY_SIX_MONTH (3 years).
  // INVALID:
  // THIRTY_SIX_MONTH:
  // TWELVE_MONTH:
  optional string plan = 11 [json_name = "plan"];

  // [Output Only] URL of the region where this commitment may be used.
  optional string region = 12 [json_name = "region"];

  // List of create-on-create reservations for this commitment.
  repeated Reservation reservations = 13 [json_name = "reservations"];

  // A list of commitment amounts for particular resources. Note that VCPU and
  // MEMORY resource commitments must occur together.
  repeated ResourceCommitment resources = 14 [json_name = "resources"];

  // [Output Only] Server-defined URL for the resource.
  optional string self_link = 15 [json_name = "selfLink"];

  // Source commitment to be split into a new commitment.
  optional string split_source_commitment = 16
      [json_name = "splitSourceCommitment"];

  // [Output Only] Commitment start time in RFC3339 text format.
  optional string start_timestamp = 17 [json_name = "startTimestamp"];

  // [Output Only] Status of the commitment with regards to eventual expiration
  // (each commitment has an end date defined). One of the following values:
  // NOT_YET_ACTIVE, ACTIVE, EXPIRED.
  // ACTIVE:
  // CANCELLED: Deprecate CANCELED status. Will use separate status to
  // differentiate cancel by mergeCud or manual cancellation.
  // CREATING:
  // EXPIRED:
  // NOT_YET_ACTIVE:
  optional string status = 18 [json_name = "status"];

  // [Output Only] An optional, human-readable explanation of the status.
  optional string status_message = 19 [json_name = "statusMessage"];

  // The type of commitment, which affects the discount rate and the eligible
  // resources. Type MEMORY_OPTIMIZED specifies a commitment that will only
  // apply to memory optimized machines. Type ACCELERATOR_OPTIMIZED specifies a
  // commitment that will only apply to accelerator optimized machines.
  // ACCELERATOR_OPTIMIZED:
  // ACCELERATOR_OPTIMIZED_A3:
  // ACCELERATOR_OPTIMIZED_A3_MEGA:
  // COMPUTE_OPTIMIZED:
  // COMPUTE_OPTIMIZED_C2D:
  // COMPUTE_OPTIMIZED_C3:
  // COMPUTE_OPTIMIZED_C3D:
  // COMPUTE_OPTIMIZED_H3:
  // GENERAL_PURPOSE:
  // GENERAL_PURPOSE_C4:
  // GENERAL_PURPOSE_E2:
  // GENERAL_PURPOSE_N2:
  // GENERAL_PURPOSE_N2D:
  // GENERAL_PURPOSE_N4:
  // GENERAL_PURPOSE_T2D:
  // GRAPHICS_OPTIMIZED:
  // MEMORY_OPTIMIZED:
  // MEMORY_OPTIMIZED_M3:
  // STORAGE_OPTIMIZED_Z3:
  // TYPE_UNSPECIFIED:
  optional string type = 20 [json_name = "type"];
}

message CommitmentAggregatedList {
  // [Output Only] Unique identifier for the resource; defined by the server.
  optional string id = 1 [json_name = "id"];

  // A list of CommitmentsScopedList resources.
  map<string, CommitmentsScopedList> items = 2 [json_name = "items"];

  // [Output Only] Type of resource. Always compute#commitmentAggregatedList for
  // aggregated lists of commitments.
  optional string kind = 3 [json_name = "kind"];

  // [Output Only] This token allows you to get the next page of results for
  // list requests. If the number of results is larger than maxResults, use the
  // nextPageToken as a value for the query parameter pageToken in the next list
  // request. Subsequent list requests will have their own nextPageToken to
  // continue paging through the results.
  optional string next_page_token = 4 [json_name = "nextPageToken"];

  // [Output Only] Server-defined URL for this resource.
  optional string self_link = 5 [json_name = "selfLink"];

  // [Output Only] Unreachable resources.
  repeated string unreachables = 6 [json_name = "unreachables"];

  message Warning {
    // [Output Only] A warning code, if applicable. For example, Compute Engine
    // returns NO_RESULTS_ON_PAGE if there are no results in the response.
    // CLEANUP_FAILED: Warning about failed cleanup of transient changes made by
    // a failed operation.
    // DEPRECATED_RESOURCE_USED: A link to a deprecated resource was created.
    // DEPRECATED_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as deprecated
    // DISK_SIZE_LARGER_THAN_IMAGE_SIZE: The user created a boot disk that is
    // larger than image size.
    // EXPERIMENTAL_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as experimental
    // EXTERNAL_API_WARNING: Warning that is present in an external api call
    // FIELD_VALUE_OVERRIDEN: Warning that value of a field has been overridden.
    // Deprecated unused field.
    // INJECTED_KERNELS_DEPRECATED: The operation involved use of an injected
    // kernel, which is deprecated.
    // INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB: A WEIGHTED_MAGLEV backend
    // service is associated with a health check that is not of type
    // HTTP/HTTPS/HTTP2.
    // LARGE_DEPLOYMENT_WARNING: When deploying a deployment with a exceedingly
    // large number of resources
    // LIST_OVERHEAD_QUOTA_EXCEED: Resource can't be retrieved due to list
    // overhead quota exceed which captures the amount of resources filtered out
    // by user-defined list filter.
    // MISSING_TYPE_DEPENDENCY: A resource depends on a missing type
    // NEXT_HOP_ADDRESS_NOT_ASSIGNED: The route's nextHopIp address is not
    // assigned to an instance on the network.
    // NEXT_HOP_CANNOT_IP_FORWARD: The route's next hop instance cannot ip
    // forward.
    // NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE: The route's nextHopInstance URL
    // refers to an instance that does not have an ipv6 interface on the same
    // network as the route.
    // NEXT_HOP_INSTANCE_NOT_FOUND: The route's nextHopInstance URL refers to an
    // instance that does not exist.
    // NEXT_HOP_INSTANCE_NOT_ON_NETWORK: The route's nextHopInstance URL refers
    // to an instance that is not on the same network as the route.
    // NEXT_HOP_NOT_RUNNING: The route's next hop instance does not have a
    // status of RUNNING.
    // NOT_CRITICAL_ERROR: Error which is not critical. We decided to continue
    // the process despite the mentioned error.
    // NO_RESULTS_ON_PAGE: No results are present on a particular list page.
    // PARTIAL_SUCCESS: Success is reported, but some results may be missing due
    // to errors
    // REQUIRED_TOS_AGREEMENT: The user attempted to use a resource that
    // requires a TOS they have not accepted.
    // RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING: Warning that a resource is in
    // use.
    // RESOURCE_NOT_DELETED: One or more of the resources set to auto-delete
    // could not be deleted because they were in use.
    // SCHEMA_VALIDATION_IGNORED: When a resource schema validation is ignored.
    // SINGLE_INSTANCE_PROPERTY_TEMPLATE: Instance template used in instance
    // group manager is valid as such, but its application does not make a lot
    // of sense, because it allows only single instance in instance group.
    // UNDECLARED_PROPERTIES: When undeclared properties in the schema are
    // present
    // UNREACHABLE: A given scope cannot be reached.
    optional string code = 1 [json_name = "code"];

    message DataItem {
      // [Output Only] A key that provides more detail on the warning being
      // returned. For example, for warnings where there are no results in a
      // list request for a particular zone, this key might be scope and the key
      // value might be the zone name. Other examples might be a key indicating
      // a deprecated resource and a suggested replacement, or a warning about
      // invalid network settings (for example, if an instance attempts to
      // perform IP forwarding but is not enabled for IP forwarding).
      optional string key = 1 [json_name = "key"];

      // [Output Only] A warning data value corresponding to the key.
      optional string value = 2 [json_name = "value"];
    }

    // [Output Only] Metadata about this warning in key: value format. For
    // example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    repeated DataItem data = 2 [json_name = "data"];

    // [Output Only] A human-readable description of the warning code.
    optional string message = 3 [json_name = "message"];
  }

  // [Output Only] Informational warning message.
  optional Warning warning = 7 [json_name = "warning"];
}

// Contains a list of Commitment resources.
message CommitmentList {
  // [Output Only] Unique identifier for the resource; defined by the server.
  optional string id = 1 [json_name = "id"];

  // A list of Commitment resources.
  repeated Commitment items = 2 [json_name = "items"];

  // [Output Only] Type of resource. Always compute#commitmentList for lists of
  // commitments.
  optional string kind = 3 [json_name = "kind"];

  // [Output Only] This token allows you to get the next page of results for
  // list requests. If the number of results is larger than maxResults, use the
  // nextPageToken as a value for the query parameter pageToken in the next list
  // request. Subsequent list requests will have their own nextPageToken to
  // continue paging through the results.
  optional string next_page_token = 4 [json_name = "nextPageToken"];

  // [Output Only] Server-defined URL for this resource.
  optional string self_link = 5 [json_name = "selfLink"];

  message Warning {
    // [Output Only] A warning code, if applicable. For example, Compute Engine
    // returns NO_RESULTS_ON_PAGE if there are no results in the response.
    // CLEANUP_FAILED: Warning about failed cleanup of transient changes made by
    // a failed operation.
    // DEPRECATED_RESOURCE_USED: A link to a deprecated resource was created.
    // DEPRECATED_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as deprecated
    // DISK_SIZE_LARGER_THAN_IMAGE_SIZE: The user created a boot disk that is
    // larger than image size.
    // EXPERIMENTAL_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as experimental
    // EXTERNAL_API_WARNING: Warning that is present in an external api call
    // FIELD_VALUE_OVERRIDEN: Warning that value of a field has been overridden.
    // Deprecated unused field.
    // INJECTED_KERNELS_DEPRECATED: The operation involved use of an injected
    // kernel, which is deprecated.
    // INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB: A WEIGHTED_MAGLEV backend
    // service is associated with a health check that is not of type
    // HTTP/HTTPS/HTTP2.
    // LARGE_DEPLOYMENT_WARNING: When deploying a deployment with a exceedingly
    // large number of resources
    // LIST_OVERHEAD_QUOTA_EXCEED: Resource can't be retrieved due to list
    // overhead quota exceed which captures the amount of resources filtered out
    // by user-defined list filter.
    // MISSING_TYPE_DEPENDENCY: A resource depends on a missing type
    // NEXT_HOP_ADDRESS_NOT_ASSIGNED: The route's nextHopIp address is not
    // assigned to an instance on the network.
    // NEXT_HOP_CANNOT_IP_FORWARD: The route's next hop instance cannot ip
    // forward.
    // NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE: The route's nextHopInstance URL
    // refers to an instance that does not have an ipv6 interface on the same
    // network as the route.
    // NEXT_HOP_INSTANCE_NOT_FOUND: The route's nextHopInstance URL refers to an
    // instance that does not exist.
    // NEXT_HOP_INSTANCE_NOT_ON_NETWORK: The route's nextHopInstance URL refers
    // to an instance that is not on the same network as the route.
    // NEXT_HOP_NOT_RUNNING: The route's next hop instance does not have a
    // status of RUNNING.
    // NOT_CRITICAL_ERROR: Error which is not critical. We decided to continue
    // the process despite the mentioned error.
    // NO_RESULTS_ON_PAGE: No results are present on a particular list page.
    // PARTIAL_SUCCESS: Success is reported, but some results may be missing due
    // to errors
    // QUOTA_INFO_UNAVAILABLE: Quota information is not available to client
    // requests (e.g: regions.list).
    // REQUIRED_TOS_AGREEMENT: The user attempted to use a resource that
    // requires a TOS they have not accepted.
    // RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING: Warning that a resource is in
    // use.
    // RESOURCE_NOT_DELETED: One or more of the resources set to auto-delete
    // could not be deleted because they were in use.
    // SCHEMA_VALIDATION_IGNORED: When a resource schema validation is ignored.
    // SINGLE_INSTANCE_PROPERTY_TEMPLATE: Instance template used in instance
    // group manager is valid as such, but its application does not make a lot
    // of sense, because it allows only single instance in instance group.
    // UNDECLARED_PROPERTIES: When undeclared properties in the schema are
    // present
    // UNREACHABLE: A given scope cannot be reached.
    optional string code = 1 [json_name = "code"];

    message DataItem {
      // [Output Only] A key that provides more detail on the warning being
      // returned. For example, for warnings where there are no results in a
      // list request for a particular zone, this key might be scope and the key
      // value might be the zone name. Other examples might be a key indicating
      // a deprecated resource and a suggested replacement, or a warning about
      // invalid network settings (for example, if an instance attempts to
      // perform IP forwarding but is not enabled for IP forwarding).
      optional string key = 1 [json_name = "key"];

      // [Output Only] A warning data value corresponding to the key.
      optional string value = 2 [json_name = "value"];
    }

    // [Output Only] Metadata about this warning in key: value format. For
    // example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    repeated DataItem data = 2 [json_name = "data"];

    // [Output Only] A human-readable description of the warning code.
    optional string message = 3 [json_name = "message"];
  }

  // [Output Only] Informational warning message.
  optional Warning warning = 6 [json_name = "warning"];
}

message CommitmentsScopedList {
  // [Output Only] A list of commitments contained in this scope.
  repeated Commitment commitments = 1 [json_name = "commitments"];

  message Warning {
    // [Output Only] A warning code, if applicable. For example, Compute Engine
    // returns NO_RESULTS_ON_PAGE if there are no results in the response.
    // CLEANUP_FAILED: Warning about failed cleanup of transient changes made by
    // a failed operation.
    // DEPRECATED_RESOURCE_USED: A link to a deprecated resource was created.
    // DEPRECATED_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as deprecated
    // DISK_SIZE_LARGER_THAN_IMAGE_SIZE: The user created a boot disk that is
    // larger than image size.
    // EXPERIMENTAL_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as experimental
    // EXTERNAL_API_WARNING: Warning that is present in an external api call
    // FIELD_VALUE_OVERRIDEN: Warning that value of a field has been overridden.
    // Deprecated unused field.
    // INJECTED_KERNELS_DEPRECATED: The operation involved use of an injected
    // kernel, which is deprecated.
    // INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB: A WEIGHTED_MAGLEV backend
    // service is associated with a health check that is not of type
    // HTTP/HTTPS/HTTP2.
    // LARGE_DEPLOYMENT_WARNING: When deploying a deployment with a exceedingly
    // large number of resources
    // LIST_OVERHEAD_QUOTA_EXCEED: Resource can't be retrieved due to list
    // overhead quota exceed which captures the amount of resources filtered out
    // by user-defined list filter.
    // MISSING_TYPE_DEPENDENCY: A resource depends on a missing type
    // NEXT_HOP_ADDRESS_NOT_ASSIGNED: The route's nextHopIp address is not
    // assigned to an instance on the network.
    // NEXT_HOP_CANNOT_IP_FORWARD: The route's next hop instance cannot ip
    // forward.
    // NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE: The route's nextHopInstance URL
    // refers to an instance that does not have an ipv6 interface on the same
    // network as the route.
    // NEXT_HOP_INSTANCE_NOT_FOUND: The route's nextHopInstance URL refers to an
    // instance that does not exist.
    // NEXT_HOP_INSTANCE_NOT_ON_NETWORK: The route's nextHopInstance URL refers
    // to an instance that is not on the same network as the route.
    // NEXT_HOP_NOT_RUNNING: The route's next hop instance does not have a
    // status of RUNNING.
    // NOT_CRITICAL_ERROR: Error which is not critical. We decided to continue
    // the process despite the mentioned error.
    // NO_RESULTS_ON_PAGE: No results are present on a particular list page.
    // PARTIAL_SUCCESS: Success is reported, but some results may be missing due
    // to errors
    // REQUIRED_TOS_AGREEMENT: The user attempted to use a resource that
    // requires a TOS they have not accepted.
    // RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING: Warning that a resource is in
    // use.
    // RESOURCE_NOT_DELETED: One or more of the resources set to auto-delete
    // could not be deleted because they were in use.
    // SCHEMA_VALIDATION_IGNORED: When a resource schema validation is ignored.
    // SINGLE_INSTANCE_PROPERTY_TEMPLATE: Instance template used in instance
    // group manager is valid as such, but its application does not make a lot
    // of sense, because it allows only single instance in instance group.
    // UNDECLARED_PROPERTIES: When undeclared properties in the schema are
    // present
    // UNREACHABLE: A given scope cannot be reached.
    optional string code = 1 [json_name = "code"];

    message DataItem {
      // [Output Only] A key that provides more detail on the warning being
      // returned. For example, for warnings where there are no results in a
      // list request for a particular zone, this key might be scope and the key
      // value might be the zone name. Other examples might be a key indicating
      // a deprecated resource and a suggested replacement, or a warning about
      // invalid network settings (for example, if an instance attempts to
      // perform IP forwarding but is not enabled for IP forwarding).
      optional string key = 1 [json_name = "key"];

      // [Output Only] A warning data value corresponding to the key.
      optional string value = 2 [json_name = "value"];
    }

    // [Output Only] Metadata about this warning in key: value format. For
    // example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    repeated DataItem data = 2 [json_name = "data"];

    // [Output Only] A human-readable description of the warning code.
    optional string message = 3 [json_name = "message"];
  }

  // [Output Only] Informational warning which replaces the list of commitments
  // when the list is empty.
  optional Warning warning = 2 [json_name = "warning"];
}

// Commitment for a particular license resource.
message LicenseResourceCommitment {
  // The number of licenses purchased.
  optional string amount = 1 [json_name = "amount"];

  // Specifies the core range of the instance for which this license applies.
  optional string cores_per_license = 2 [json_name = "coresPerLicense"];

  // Any applicable license URI.
  optional string license = 3 [json_name = "license"];
}

// Commitment for a particular resource (a Commitment is composed of one or more
// of these).
message ResourceCommitment {
  // Name of the accelerator type resource. Applicable only when the type is
  // ACCELERATOR.
  optional string accelerator_type = 1 [json_name = "acceleratorType"];

  // The amount of the resource purchased (in a type-dependent unit, such as
  // bytes). For vCPUs, this can just be an integer. For memory, this must be
  // provided in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of
  // memory per every vCPU.
  optional string amount = 2 [json_name = "amount"];

  // Type of resource for which this commitment applies. Possible values are
  // VCPU, MEMORY, LOCAL_SSD, and ACCELERATOR.
  // ACCELERATOR:
  // LOCAL_SSD:
  // MEMORY:
  // UNSPECIFIED:
  // VCPU:
  optional string type = 3 [json_name = "type"];
}
