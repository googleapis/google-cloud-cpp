// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the C++ microgenerator.
// If you make any local changes, they will be lost.
// file:///workspace/generator/discovery/compute_public_google_rest_v1.json
// revision: 20240220

syntax = "proto3";

package google.cloud.cpp.compute.v1;

import "google/cloud/compute/v1/internal/common_029.proto";
import "google/cloud/compute/v1/internal/common_075.proto";

// The specification for allowing client-side cross-origin requests. For more
// information about the W3C recommendation for cross-origin resource sharing
// (CORS), see Fetch API Living Standard.
message CorsPolicy {
  // In response to a preflight request, setting this to true indicates that the
  // actual request can include user credentials. This field translates to the
  // Access-Control-Allow-Credentials header. Default is false.
  optional bool allow_credentials = 1 [json_name = "allowCredentials"];

  // Specifies the content for the Access-Control-Allow-Headers header.
  repeated string allow_headers = 2 [json_name = "allowHeaders"];

  // Specifies the content for the Access-Control-Allow-Methods header.
  repeated string allow_methods = 3 [json_name = "allowMethods"];

  // Specifies a regular expression that matches allowed origins. For more
  // information about the regular expression syntax, see Syntax. An origin is
  // allowed if it matches either an item in allowOrigins or an item in
  // allowOriginRegexes. Regular expressions can only be used when the
  // loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
  repeated string allow_origin_regexes = 4 [json_name = "allowOriginRegexes"];

  // Specifies the list of origins that is allowed to do CORS requests. An
  // origin is allowed if it matches either an item in allowOrigins or an item
  // in allowOriginRegexes.
  repeated string allow_origins = 5 [json_name = "allowOrigins"];

  // If true, the setting specifies the CORS policy is disabled. The default
  // value of false, which indicates that the CORS policy is in effect.
  optional bool disabled = 6 [json_name = "disabled"];

  // Specifies the content for the Access-Control-Expose-Headers header.
  repeated string expose_headers = 7 [json_name = "exposeHeaders"];

  // Specifies how long results of a preflight request can be cached in seconds.
  // This field translates to the Access-Control-Max-Age header.
  optional int32 max_age = 8 [json_name = "maxAge"];
}

// UrlMaps A host-matching rule for a URL. If matched, will use the named
// PathMatcher to select the BackendService.
message HostRule {
  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 1 [json_name = "description"];

  // The list of host patterns to match. They must be valid hostnames with
  // optional port numbers in the format host:port. * matches any string of
  // ([a-z0-9-.]*). In that case, * must be the first character, and if followed
  // by anything, the immediate following character must be either - or .. *
  // based matching is not supported when the URL map is bound to a target gRPC
  // proxy that has the validateForProxyless field set to true.
  repeated string hosts = 2 [json_name = "hosts"];

  // The name of the PathMatcher to use to match the path portion of the URL if
  // the hostRule matches the URL's host portion.
  optional string path_matcher = 3 [json_name = "pathMatcher"];
}

// Specification for how requests are aborted as part of fault injection.
message HttpFaultAbort {
  // The HTTP status code used to abort the request. The value must be from 200
  // to 599 inclusive. For gRPC protocol, the gRPC status code is mapped to HTTP
  // status code according to this mapping table. HTTP status 200 is mapped to
  // gRPC status UNKNOWN. Injecting an OK status is currently not supported by
  // Traffic Director.
  optional uint32 http_status = 1 [json_name = "httpStatus"];

  // The percentage of traffic for connections, operations, or requests that is
  // aborted as part of fault injection. The value must be from 0.0 to 100.0
  // inclusive.
  optional double percentage = 2 [json_name = "percentage"];
}

// Specifies the delay introduced by the load balancer before forwarding the
// request to the backend service as part of fault injection.
message HttpFaultDelay {
  // Specifies the value of the fixed delay interval.
  optional Duration fixed_delay = 1 [json_name = "fixedDelay"];

  // The percentage of traffic for connections, operations, or requests for
  // which a delay is introduced as part of fault injection. The value must be
  // from 0.0 to 100.0 inclusive.
  optional double percentage = 2 [json_name = "percentage"];
}

// The specification for fault injection introduced into traffic to test the
// resiliency of clients to backend service failure. As part of fault injection,
// when clients send requests to a backend service, delays can be introduced by
// the load balancer on a percentage of requests before sending those request to
// the backend service. Similarly requests from clients can be aborted by the
// load balancer for a percentage of requests.
message HttpFaultInjection {
  // The specification for how client requests are aborted as part of fault
  // injection.
  optional HttpFaultAbort abort = 1 [json_name = "abort"];

  // The specification for how client requests are delayed as part of fault
  // injection, before being sent to a backend service.
  optional HttpFaultDelay delay = 2 [json_name = "delay"];
}

// The request and response header transformations that take effect before the
// request is passed along to the selected backendService.
message HttpHeaderAction {
  // Headers to add to a matching request before forwarding the request to the
  // backendService.
  repeated HttpHeaderOption request_headers_to_add = 1
      [json_name = "requestHeadersToAdd"];

  // A list of header names for headers that need to be removed from the request
  // before forwarding the request to the backendService.
  repeated string request_headers_to_remove = 2
      [json_name = "requestHeadersToRemove"];

  // Headers to add the response before sending the response back to the client.
  repeated HttpHeaderOption response_headers_to_add = 3
      [json_name = "responseHeadersToAdd"];

  // A list of header names for headers that need to be removed from the
  // response before sending the response back to the client.
  repeated string response_headers_to_remove = 4
      [json_name = "responseHeadersToRemove"];
}

// matchRule criteria for request header matches.
message HttpHeaderMatch {
  // The value should exactly match contents of exactMatch. Only one of
  // exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
  // rangeMatch must be set.
  optional string exact_match = 1 [json_name = "exactMatch"];

  // The name of the HTTP header to match. For matching against the HTTP
  // request's authority, use a headerMatch with the header name ":authority".
  // For matching a request's method, use the headerName ":method". When the URL
  // map is bound to a target gRPC proxy that has the validateForProxyless field
  // set to true, only non-binary user-specified custom metadata and the
  // `content-type` header are supported. The following transport-level headers
  // cannot be used in header matching rules: `:authority`, `:method`, `:path`,
  // `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`,
  // `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`,
  // `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
  optional string header_name = 2 [json_name = "headerName"];

  // If set to false, the headerMatch is considered a match if the preceding
  // match criteria are met. If set to true, the headerMatch is considered a
  // match if the preceding match criteria are NOT met. The default setting is
  // false.
  optional bool invert_match = 3 [json_name = "invertMatch"];

  // The value of the header must start with the contents of prefixMatch. Only
  // one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
  // rangeMatch must be set.
  optional string prefix_match = 4 [json_name = "prefixMatch"];

  // A header with the contents of headerName must exist. The match takes place
  // whether or not the request's header has a value. Only one of exactMatch,
  // prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be
  // set.
  optional bool present_match = 5 [json_name = "presentMatch"];

  // The header value must be an integer and its value must be in the range
  // specified in rangeMatch. If the header does not contain an integer, number
  // or is empty, the match fails. For example for a range [-5, 0] - -3 will
  // match. - 0 will not match. - 0.25 will not match. - -3someString will not
  // match. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
  // presentMatch or rangeMatch must be set. rangeMatch is not supported for
  // load balancers that have loadBalancingScheme set to EXTERNAL.
  optional Int64RangeMatch range_match = 6 [json_name = "rangeMatch"];

  // The value of the header must match the regular expression specified in
  // regexMatch. For more information about regular expression syntax, see
  // Syntax. For matching against a port specified in the HTTP request, use a
  // headerMatch with headerName set to PORT and a regular expression that
  // satisfies the RFC2616 Host header's port specifier. Only one of exactMatch,
  // prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be
  // set. Regular expressions can only be used when the loadBalancingScheme is
  // set to INTERNAL_SELF_MANAGED.
  optional string regex_match = 7 [json_name = "regexMatch"];

  // The value of the header must end with the contents of suffixMatch. Only one
  // of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
  // rangeMatch must be set.
  optional string suffix_match = 8 [json_name = "suffixMatch"];
}

// Specification determining how headers are added to requests or responses.
message HttpHeaderOption {
  // The name of the header.
  optional string header_name = 1 [json_name = "headerName"];

  // The value of the header to add.
  optional string header_value = 2 [json_name = "headerValue"];

  // If false, headerValue is appended to any values that already exist for the
  // header. If true, headerValue is set for the header, discarding any values
  // that were set for that header. The default value is false.
  optional bool replace = 3 [json_name = "replace"];
}

// HttpRouteRuleMatch criteria for a request's query parameter.
message HttpQueryParameterMatch {
  // The queryParameterMatch matches if the value of the parameter exactly
  // matches the contents of exactMatch. Only one of presentMatch, exactMatch,
  // or regexMatch must be set.
  optional string exact_match = 1 [json_name = "exactMatch"];

  // The name of the query parameter to match. The query parameter must exist in
  // the request, in the absence of which the request match fails.
  optional string name = 2 [json_name = "name"];

  // Specifies that the queryParameterMatch matches if the request contains the
  // query parameter, irrespective of whether the parameter has a value or not.
  // Only one of presentMatch, exactMatch, or regexMatch must be set.
  optional bool present_match = 3 [json_name = "presentMatch"];

  // The queryParameterMatch matches if the value of the parameter matches the
  // regular expression specified by regexMatch. For more information about
  // regular expression syntax, see Syntax. Only one of presentMatch,
  // exactMatch, or regexMatch must be set. Regular expressions can only be used
  // when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
  optional string regex_match = 4 [json_name = "regexMatch"];
}

// Specifies settings for an HTTP redirect.
message HttpRedirectAction {
  // The host that is used in the redirect response instead of the one that was
  // supplied in the request. The value must be from 1 to 255 characters.
  optional string host_redirect = 1 [json_name = "hostRedirect"];

  // If set to true, the URL scheme in the redirected request is set to HTTPS.
  // If set to false, the URL scheme of the redirected request remains the same
  // as that of the request. This must only be set for URL maps used in
  // TargetHttpProxys. Setting this true for TargetHttpsProxy is not permitted.
  // The default is set to false.
  optional bool https_redirect = 2 [json_name = "httpsRedirect"];

  // The path that is used in the redirect response instead of the one that was
  // supplied in the request. pathRedirect cannot be supplied together with
  // prefixRedirect. Supply one alone or neither. If neither is supplied, the
  // path of the original request is used for the redirect. The value must be
  // from 1 to 1024 characters.
  optional string path_redirect = 3 [json_name = "pathRedirect"];

  // The prefix that replaces the prefixMatch specified in the
  // HttpRouteRuleMatch, retaining the remaining portion of the URL before
  // redirecting the request. prefixRedirect cannot be supplied together with
  // pathRedirect. Supply one alone or neither. If neither is supplied, the path
  // of the original request is used for the redirect. The value must be from 1
  // to 1024 characters.
  optional string prefix_redirect = 4 [json_name = "prefixRedirect"];

  // The HTTP Status code to use for this RedirectAction. Supported values are:
  // - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to
  // 301. - FOUND, which corresponds to 302. - SEE_OTHER which corresponds to
  // 303. - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the
  // request method is retained. - PERMANENT_REDIRECT, which corresponds to 308.
  // In this case, the request method is retained.
  // FOUND: Http Status Code 302 - Found.
  // MOVED_PERMANENTLY_DEFAULT: Http Status Code 301 - Moved Permanently.
  // PERMANENT_REDIRECT: Http Status Code 308 - Permanent Redirect maintaining
  // HTTP method.
  // SEE_OTHER: Http Status Code 303 - See Other.
  // TEMPORARY_REDIRECT: Http Status Code 307 - Temporary Redirect maintaining
  // HTTP method.
  optional string redirect_response_code = 5
      [json_name = "redirectResponseCode"];

  // If set to true, any accompanying query portion of the original URL is
  // removed before redirecting the request. If set to false, the query portion
  // of the original URL is retained. The default is set to false.
  optional bool strip_query = 6 [json_name = "stripQuery"];
}

// The retry policy associates with HttpRouteRule
message HttpRetryPolicy {
  // Specifies the allowed number retries. This number must be > 0. If not
  // specified, defaults to 1.
  optional uint32 num_retries = 1 [json_name = "numRetries"];

  // Specifies a non-zero timeout per retry attempt. If not specified, will use
  // the timeout set in the HttpRouteAction field. If timeout in the
  // HttpRouteAction field is not set, this field uses the largest timeout among
  // all backend services associated with the route. Not supported when the URL
  // map is bound to a target gRPC proxy that has the validateForProxyless field
  // set to true.
  optional Duration per_try_timeout = 2 [json_name = "perTryTimeout"];

  // Specifies one or more conditions when this retry policy applies. Valid
  // values are: - 5xx: retry is attempted if the instance or endpoint responds
  // with any 5xx response code, or if the instance or endpoint does not respond
  // at all. For example, disconnects, reset, read timeout, connection failure,
  // and refused streams. - gateway-error: Similar to 5xx, but only applies to
  // response codes 502, 503 or 504. - connect-failure: a retry is attempted on
  // failures connecting to the instance or endpoint. For example, connection
  // timeouts. - retriable-4xx: a retry is attempted if the instance or endpoint
  // responds with a 4xx response code. The only error that you can retry is
  // error code 409. - refused-stream: a retry is attempted if the instance or
  // endpoint resets the stream with a REFUSED_STREAM error code. This reset
  // type indicates that it is safe to retry. - cancelled: a retry is attempted
  // if the gRPC status code in the response header is set to cancelled. -
  // deadline-exceeded: a retry is attempted if the gRPC status code in the
  // response header is set to deadline-exceeded. - internal: a retry is
  // attempted if the gRPC status code in the response header is set to
  // internal. - resource-exhausted: a retry is attempted if the gRPC status
  // code in the response header is set to resource-exhausted. - unavailable: a
  // retry is attempted if the gRPC status code in the response header is set to
  // unavailable. Only the following codes are supported when the URL map is
  // bound to target gRPC proxy that has validateForProxyless field set to true.
  // - cancelled - deadline-exceeded - internal - resource-exhausted -
  // unavailable
  repeated string retry_conditions = 3 [json_name = "retryConditions"];
}

message HttpRouteAction {
  // The specification for allowing client-side cross-origin requests. For more
  // information about the W3C recommendation for cross-origin resource sharing
  // (CORS), see Fetch API Living Standard. Not supported when the URL map is
  // bound to a target gRPC proxy.
  optional CorsPolicy cors_policy = 1 [json_name = "corsPolicy"];

  // The specification for fault injection introduced into traffic to test the
  // resiliency of clients to backend service failure. As part of fault
  // injection, when clients send requests to a backend service, delays can be
  // introduced by a load balancer on a percentage of requests before sending
  // those requests to the backend service. Similarly requests from clients can
  // be aborted by the load balancer for a percentage of requests. timeout and
  // retry_policy is ignored by clients that are configured with a
  // fault_injection_policy if: 1. The traffic is generated by fault injection
  // AND 2. The fault injection is not a delay fault injection. Fault injection
  // is not supported with the classic Application Load Balancer . To see which
  // load balancers support fault injection, see Load balancing: Routing and
  // traffic management features.
  optional HttpFaultInjection fault_injection_policy = 2
      [json_name = "faultInjectionPolicy"];

  // Specifies the maximum duration (timeout) for streams on the selected route.
  // Unlike the timeout field where the timeout duration starts from the time
  // the request has been fully processed (known as *end-of-stream*), the
  // duration in this field is computed from the beginning of the stream until
  // the response has been processed, including all retries. A stream that does
  // not complete in this duration is closed. If not specified, this field uses
  // the maximum maxStreamDuration value among all backend services associated
  // with the route. This field is only allowed if the Url map is used with
  // backend services with loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  optional Duration max_stream_duration = 3 [json_name = "maxStreamDuration"];

  // Specifies the policy on how requests intended for the route's backends are
  // shadowed to a separate mirrored backend service. The load balancer does not
  // wait for responses from the shadow service. Before sending traffic to the
  // shadow service, the host / authority header is suffixed with -shadow. Not
  // supported when the URL map is bound to a target gRPC proxy that has the
  // validateForProxyless field set to true.
  optional RequestMirrorPolicy request_mirror_policy = 4
      [json_name = "requestMirrorPolicy"];

  // Specifies the retry policy associated with this route.
  optional HttpRetryPolicy retry_policy = 5 [json_name = "retryPolicy"];

  // Specifies the timeout for the selected route. Timeout is computed from the
  // time the request has been fully processed (known as *end-of-stream*) up
  // until the response has been processed. Timeout includes all retries. If not
  // specified, this field uses the largest timeout among all backend services
  // associated with the route. Not supported when the URL map is bound to a
  // target gRPC proxy that has validateForProxyless field set to true.
  optional Duration timeout = 6 [json_name = "timeout"];

  // The spec to modify the URL of the request, before forwarding the request to
  // the matched service. urlRewrite is the only action supported in UrlMaps for
  // classic Application Load Balancers. Not supported when the URL map is bound
  // to a target gRPC proxy that has the validateForProxyless field set to true.
  optional UrlRewrite url_rewrite = 7 [json_name = "urlRewrite"];

  // A list of weighted backend services to send traffic to when a route match
  // occurs. The weights determine the fraction of traffic that flows to their
  // corresponding backend service. If all traffic needs to go to a single
  // backend service, there must be one weightedBackendService with weight set
  // to a non-zero number. After a backend service is identified and before
  // forwarding the request to the backend service, advanced routing actions
  // such as URL rewrites and header transformations are applied depending on
  // additional settings specified in this HttpRouteAction.
  repeated WeightedBackendService weighted_backend_services = 8
      [json_name = "weightedBackendServices"];
}

// The HttpRouteRule setting specifies how to match an HTTP request and the
// corresponding routing action that load balancing proxies perform.
message HttpRouteRule {
  // The short description conveying the intent of this routeRule. The
  // description can have a maximum length of 1024 characters.
  optional string description = 1 [json_name = "description"];

  // Specifies changes to request and response headers that need to take effect
  // for the selected backendService. The headerAction value specified here is
  // applied before the matching pathMatchers[].headerAction and after
  // pathMatchers[].routeRules[].routeAction.weightedBackendService.backendServiceWeightAction[].headerAction
  // HeaderAction is not supported for load balancers that have their
  // loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
  // bound to a target gRPC proxy that has validateForProxyless field set to
  // true.
  optional HttpHeaderAction header_action = 2 [json_name = "headerAction"];

  // The list of criteria for matching attributes of a request to this
  // routeRule. This list has OR semantics: the request matches this routeRule
  // when any of the matchRules are satisfied. However predicates within a given
  // matchRule have AND semantics. All predicates within a matchRule must match
  // for the request to match the rule.
  repeated HttpRouteRuleMatch match_rules = 3 [json_name = "matchRules"];

  // For routeRules within a given pathMatcher, priority determines the order in
  // which a load balancer interprets routeRules. RouteRules are evaluated in
  // order of priority, from the lowest to highest number. The priority of a
  // rule decreases as its number increases (1, 2, 3, N+1). The first rule that
  // matches the request is applied. You cannot configure two or more routeRules
  // with the same priority. Priority for each rule must be set to a number from
  // 0 to 2147483647 inclusive. Priority numbers can have gaps, which enable you
  // to add or remove rules in the future without affecting the rest of the
  // rules. For example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority
  // numbers to which you could add rules numbered from 6 to 8, 10 to 11, and 13
  // to 15 in the future without any impact on existing rules.
  optional int32 priority = 4 [json_name = "priority"];

  // In response to a matching matchRule, the load balancer performs advanced
  // routing actions, such as URL rewrites and header transformations, before
  // forwarding the request to the selected backend. If routeAction specifies
  // any weightedBackendServices, service must not be set. Conversely if service
  // is set, routeAction cannot contain any weightedBackendServices. Only one of
  // urlRedirect, service or routeAction.weightedBackendService must be set. URL
  // maps for classic Application Load Balancers only support the urlRewrite
  // action within a route rule's routeAction.
  optional HttpRouteAction route_action = 5 [json_name = "routeAction"];

  // The full or partial URL of the backend service resource to which traffic is
  // directed if this rule is matched. If routeAction is also specified,
  // advanced routing actions, such as URL rewrites, take effect before sending
  // the request to the backend. However, if service is specified, routeAction
  // cannot contain any weightedBackendServices. Conversely, if routeAction
  // specifies any weightedBackendServices, service must not be specified. Only
  // one of urlRedirect, service or routeAction.weightedBackendService must be
  // set.
  optional string service = 6 [json_name = "service"];

  // When this rule is matched, the request is redirected to a URL specified by
  // urlRedirect. If urlRedirect is specified, service or routeAction must not
  // be set. Not supported when the URL map is bound to a target gRPC proxy.
  optional HttpRedirectAction url_redirect = 7 [json_name = "urlRedirect"];
}

// HttpRouteRuleMatch specifies a set of criteria for matching requests to an
// HttpRouteRule. All specified criteria must be satisfied for a match to occur.
message HttpRouteRuleMatch {
  // For satisfying the matchRule condition, the path of the request must
  // exactly match the value specified in fullPathMatch after removing any query
  // parameters and anchor that may be part of the original URL. fullPathMatch
  // must be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch
  // or regexMatch must be specified.
  optional string full_path_match = 1 [json_name = "fullPathMatch"];

  // Specifies a list of header match criteria, all of which must match
  // corresponding headers in the request.
  repeated HttpHeaderMatch header_matches = 2 [json_name = "headerMatches"];

  // Specifies that prefixMatch and fullPathMatch matches are case sensitive.
  // The default value is false. ignoreCase must not be used with regexMatch.
  // Not supported when the URL map is bound to a target gRPC proxy.
  optional bool ignore_case = 3 [json_name = "ignoreCase"];

  // Opaque filter criteria used by the load balancer to restrict routing
  // configuration to a limited set of xDS compliant clients. In their xDS
  // requests to the load balancer, xDS clients present node metadata. When
  // there is a match, the relevant routing configuration is made available to
  // those proxies. For each metadataFilter in this list, if its
  // filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels
  // must match the corresponding label provided in the metadata. If its
  // filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must
  // match with corresponding labels provided in the metadata. If multiple
  // metadata filters are specified, all of them need to be satisfied in order
  // to be considered a match. metadataFilters specified here is applied after
  // those specified in ForwardingRule that refers to the UrlMap this
  // HttpRouteRuleMatch belongs to. metadataFilters only applies to load
  // balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED. Not
  // supported when the URL map is bound to a target gRPC proxy that has
  // validateForProxyless field set to true.
  repeated MetadataFilter metadata_filters = 4 [json_name = "metadataFilters"];

  // If specified, the route is a pattern match expression that must match the
  // :path header once the query string is removed. A pattern match allows you
  // to match - The value must be between 1 and 1024 characters - The pattern
  // must start with a leading slash ("/") - There may be no more than 5
  // operators in pattern Precisely one of prefix_match, full_path_match,
  // regex_match or path_template_match must be set.
  optional string path_template_match = 8 [json_name = "pathTemplateMatch"];

  // For satisfying the matchRule condition, the request's path must begin with
  // the specified prefixMatch. prefixMatch must begin with a /. The value must
  // be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch or
  // regexMatch must be specified.
  optional string prefix_match = 5 [json_name = "prefixMatch"];

  // Specifies a list of query parameter match criteria, all of which must match
  // corresponding query parameters in the request. Not supported when the URL
  // map is bound to a target gRPC proxy.
  repeated HttpQueryParameterMatch query_parameter_matches = 6
      [json_name = "queryParameterMatches"];

  // For satisfying the matchRule condition, the path of the request must
  // satisfy the regular expression specified in regexMatch after removing any
  // query parameters and anchor supplied with the original URL. For more
  // information about regular expression syntax, see Syntax. Only one of
  // prefixMatch, fullPathMatch or regexMatch must be specified. Regular
  // expressions can only be used when the loadBalancingScheme is set to
  // INTERNAL_SELF_MANAGED.
  optional string regex_match = 7 [json_name = "regexMatch"];
}

// HttpRouteRuleMatch criteria for field values that must stay within the
// specified integer range.
message Int64RangeMatch {
  // The end of the range (exclusive) in signed long integer format.
  optional string range_end = 1 [json_name = "rangeEnd"];

  // The start of the range (inclusive) in signed long integer format.
  optional string range_start = 2 [json_name = "rangeStart"];
}

// A matcher for the path portion of the URL. The BackendService from the
// longest-matched rule will serve the URL. If no rule was matched, the default
// service is used.
message PathMatcher {
  // defaultRouteAction takes effect when none of the pathRules or routeRules
  // match. The load balancer performs advanced routing actions, such as URL
  // rewrites and header transformations, before forwarding the request to the
  // selected backend. If defaultRouteAction specifies any
  // weightedBackendServices, defaultService must not be set. Conversely if
  // defaultService is set, defaultRouteAction cannot contain any
  // weightedBackendServices. Only one of defaultRouteAction or
  // defaultUrlRedirect must be set. URL maps for classic Application Load
  // Balancers only support the urlRewrite action within a path matcher's
  // defaultRouteAction.
  optional HttpRouteAction default_route_action = 1
      [json_name = "defaultRouteAction"];

  // The full or partial URL to the BackendService resource. This URL is used if
  // none of the pathRules or routeRules defined by this PathMatcher are
  // matched. For example, the following are all valid URLs to a BackendService
  // resource: - https://www.googleapis.com/compute/v1/projects/project
  // /global/backendServices/backendService -
  // compute/v1/projects/project/global/backendServices/backendService -
  // global/backendServices/backendService If defaultRouteAction is also
  // specified, advanced routing actions, such as URL rewrites, take effect
  // before sending the request to the backend. However, if defaultService is
  // specified, defaultRouteAction cannot contain any weightedBackendServices.
  // Conversely, if defaultRouteAction specifies any weightedBackendServices,
  // defaultService must not be specified. Only one of defaultService,
  // defaultUrlRedirect , or defaultRouteAction.weightedBackendService must be
  // set. Authorization requires one or more of the following Google IAM
  // permissions on the specified resource default_service: -
  // compute.backendBuckets.use - compute.backendServices.use
  optional string default_service = 2 [json_name = "defaultService"];

  // When none of the specified pathRules or routeRules match, the request is
  // redirected to a URL specified by defaultUrlRedirect. If defaultUrlRedirect
  // is specified, defaultService or defaultRouteAction must not be set. Not
  // supported when the URL map is bound to a target gRPC proxy.
  optional HttpRedirectAction default_url_redirect = 3
      [json_name = "defaultUrlRedirect"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 4 [json_name = "description"];

  // Specifies changes to request and response headers that need to take effect
  // for the selected backend service. HeaderAction specified here are applied
  // after the matching HttpRouteRule HeaderAction and before the HeaderAction
  // in the UrlMap HeaderAction is not supported for load balancers that have
  // their loadBalancingScheme set to EXTERNAL. Not supported when the URL map
  // is bound to a target gRPC proxy that has validateForProxyless field set to
  // true.
  optional HttpHeaderAction header_action = 5 [json_name = "headerAction"];

  // The name to which this PathMatcher is referred by the HostRule.
  optional string name = 6 [json_name = "name"];

  // The list of path rules. Use this list instead of routeRules when routing
  // based on simple path matching is all that's required. The order by which
  // path rules are specified does not matter. Matches are always done on the
  // longest-path-first basis. For example: a pathRule with a path /a/b/c/* will
  // match before /a/b/* irrespective of the order in which those paths appear
  // in this list. Within a given pathMatcher, only one of pathRules or
  // routeRules must be set.
  repeated PathRule path_rules = 7 [json_name = "pathRules"];

  // The list of HTTP route rules. Use this list instead of pathRules when
  // advanced route matching and routing actions are desired. routeRules are
  // evaluated in order of priority, from the lowest to highest number. Within a
  // given pathMatcher, you can set only one of pathRules or routeRules.
  repeated HttpRouteRule route_rules = 8 [json_name = "routeRules"];
}

// A path-matching rule for a URL. If matched, will use the specified
// BackendService to handle the traffic arriving at this URL.
message PathRule {
  // The list of path patterns to match. Each must start with / and the only
  // place a * is allowed is at the end following a /. The string fed to the
  // path matcher does not include any text after the first ? or #, and those
  // chars are not allowed here.
  repeated string paths = 1 [json_name = "paths"];

  // In response to a matching path, the load balancer performs advanced routing
  // actions, such as URL rewrites and header transformations, before forwarding
  // the request to the selected backend. If routeAction specifies any
  // weightedBackendServices, service must not be set. Conversely if service is
  // set, routeAction cannot contain any weightedBackendServices. Only one of
  // routeAction or urlRedirect must be set. URL maps for classic Application
  // Load Balancers only support the urlRewrite action within a path rule's
  // routeAction.
  optional HttpRouteAction route_action = 2 [json_name = "routeAction"];

  // The full or partial URL of the backend service resource to which traffic is
  // directed if this rule is matched. If routeAction is also specified,
  // advanced routing actions, such as URL rewrites, take effect before sending
  // the request to the backend. However, if service is specified, routeAction
  // cannot contain any weightedBackendServices. Conversely, if routeAction
  // specifies any weightedBackendServices, service must not be specified. Only
  // one of urlRedirect, service or routeAction.weightedBackendService must be
  // set.
  optional string service = 3 [json_name = "service"];

  // When a path pattern is matched, the request is redirected to a URL
  // specified by urlRedirect. If urlRedirect is specified, service or
  // routeAction must not be set. Not supported when the URL map is bound to a
  // target gRPC proxy.
  optional HttpRedirectAction url_redirect = 4 [json_name = "urlRedirect"];
}

// A policy that specifies how requests intended for the route's backends are
// shadowed to a separate mirrored backend service. The load balancer doesn't
// wait for responses from the shadow service. Before sending traffic to the
// shadow service, the host or authority header is suffixed with -shadow.
message RequestMirrorPolicy {
  // The full or partial URL to the BackendService resource being mirrored to.
  // The backend service configured for a mirroring policy must reference
  // backends that are of the same type as the original backend service matched
  // in the URL map. Serverless NEG backends are not currently supported as a
  // mirrored backend service.
  optional string backend_service = 1 [json_name = "backendService"];
}

message TestFailure {
  // The actual output URL evaluated by a load balancer containing the scheme,
  // host, path and query parameters.
  optional string actual_output_url = 1 [json_name = "actualOutputUrl"];

  // Actual HTTP status code for rule with `urlRedirect` calculated by load
  // balancer
  optional int32 actual_redirect_response_code = 2
      [json_name = "actualRedirectResponseCode"];

  // BackendService or BackendBucket returned by load balancer.
  optional string actual_service = 3 [json_name = "actualService"];

  // The expected output URL evaluated by a load balancer containing the scheme,
  // host, path and query parameters.
  optional string expected_output_url = 4 [json_name = "expectedOutputUrl"];

  // Expected HTTP status code for rule with `urlRedirect` calculated by load
  // balancer
  optional int32 expected_redirect_response_code = 5
      [json_name = "expectedRedirectResponseCode"];

  // Expected BackendService or BackendBucket resource the given URL should be
  // mapped to.
  optional string expected_service = 6 [json_name = "expectedService"];

  // HTTP headers of the request.
  repeated UrlMapTestHeader headers = 7 [json_name = "headers"];

  // Host portion of the URL.
  optional string host = 8 [json_name = "host"];

  // Path portion including query parameters in the URL.
  optional string path = 9 [json_name = "path"];
}

// Represents a URL Map resource. Compute Engine has two URL Map resources: *
// [Global](/compute/docs/reference/rest/v1/urlMaps) *
// [Regional](/compute/docs/reference/rest/v1/regionUrlMaps) A URL map resource
// is a component of certain types of cloud load balancers and Traffic Director:
// * urlMaps are used by global external Application Load Balancers, classic
// Application Load Balancers, and cross-region internal Application Load
// Balancers. * regionUrlMaps are used by internal Application Load Balancers,
// regional external Application Load Balancers and regional internal
// Application Load Balancers. For a list of supported URL map features by the
// load balancer type, see the Load balancing features: Routing and traffic
// management table. For a list of supported URL map features for Traffic
// Director, see the Traffic Director features: Routing and traffic management
// table. This resource defines mappings from hostnames and URL paths to either
// a backend service or a backend bucket. To use the global urlMaps resource,
// the backend service must have a loadBalancingScheme of either EXTERNAL or
// INTERNAL_SELF_MANAGED. To use the regionUrlMaps resource, the backend service
// must have a loadBalancingScheme of INTERNAL_MANAGED. For more information,
// read URL Map Concepts.
message UrlMap {
  // [Output Only] Creation timestamp in RFC3339 text format.
  optional string creation_timestamp = 1 [json_name = "creationTimestamp"];

  // defaultRouteAction takes effect when none of the hostRules match. The load
  // balancer performs advanced routing actions, such as URL rewrites and header
  // transformations, before forwarding the request to the selected backend. If
  // defaultRouteAction specifies any weightedBackendServices, defaultService
  // must not be set. Conversely if defaultService is set, defaultRouteAction
  // cannot contain any weightedBackendServices. Only one of defaultRouteAction
  // or defaultUrlRedirect must be set. URL maps for classic Application Load
  // Balancers only support the urlRewrite action within defaultRouteAction.
  // defaultRouteAction has no effect when the URL map is bound to a target gRPC
  // proxy that has the validateForProxyless field set to true.
  optional HttpRouteAction default_route_action = 2
      [json_name = "defaultRouteAction"];

  // The full or partial URL of the defaultService resource to which traffic is
  // directed if none of the hostRules match. If defaultRouteAction is also
  // specified, advanced routing actions, such as URL rewrites, take effect
  // before sending the request to the backend. However, if defaultService is
  // specified, defaultRouteAction cannot contain any weightedBackendServices.
  // Conversely, if routeAction specifies any weightedBackendServices, service
  // must not be specified. Only one of defaultService, defaultUrlRedirect , or
  // defaultRouteAction.weightedBackendService must be set. defaultService has
  // no effect when the URL map is bound to a target gRPC proxy that has the
  // validateForProxyless field set to true.
  optional string default_service = 3 [json_name = "defaultService"];

  // When none of the specified hostRules match, the request is redirected to a
  // URL specified by defaultUrlRedirect. If defaultUrlRedirect is specified,
  // defaultService or defaultRouteAction must not be set. Not supported when
  // the URL map is bound to a target gRPC proxy.
  optional HttpRedirectAction default_url_redirect = 4
      [json_name = "defaultUrlRedirect"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 5 [json_name = "description"];

  // Fingerprint of this resource. A hash of the contents stored in this object.
  // This field is used in optimistic locking. This field is ignored when
  // inserting a UrlMap. An up-to-date fingerprint must be provided in order to
  // update the UrlMap, otherwise the request will fail with error 412
  // conditionNotMet. To see the latest fingerprint, make a get() request to
  // retrieve a UrlMap.
  optional string fingerprint = 6 [json_name = "fingerprint"];

  // Specifies changes to request and response headers that need to take effect
  // for the selected backendService. The headerAction specified here take
  // effect after headerAction specified under pathMatcher. headerAction is not
  // supported for load balancers that have their loadBalancingScheme set to
  // EXTERNAL. Not supported when the URL map is bound to a target gRPC proxy
  // that has validateForProxyless field set to true.
  optional HttpHeaderAction header_action = 7 [json_name = "headerAction"];

  // The list of host rules to use against the URL.
  repeated HostRule host_rules = 8 [json_name = "hostRules"];

  // [Output Only] The unique identifier for the resource. This identifier is
  // defined by the server.
  optional string id = 9 [json_name = "id"];

  // [Output Only] Type of the resource. Always compute#urlMaps for url maps.
  optional string kind = 10 [json_name = "kind"];

  // Name of the resource. Provided by the client when the resource is created.
  // The name must be 1-63 characters long, and comply with RFC1035.
  // Specifically, the name must be 1-63 characters long and match the regular
  // expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  // must be a lowercase letter, and all following characters must be a dash,
  // lowercase letter, or digit, except the last character, which cannot be a
  // dash.
  optional string name = 11 [json_name = "name"];

  // The list of named PathMatchers to use against the URL.
  repeated PathMatcher path_matchers = 12 [json_name = "pathMatchers"];

  // [Output Only] URL of the region where the regional URL map resides. This
  // field is not applicable to global URL maps. You must specify this field as
  // part of the HTTP request URL. It is not settable as a field in the request
  // body.
  optional string region = 13 [json_name = "region"];

  // [Output Only] Server-defined URL for the resource.
  optional string self_link = 14 [json_name = "selfLink"];

  // The list of expected URL mapping tests. Request to update the UrlMap
  // succeeds only if all test cases pass. You can specify a maximum of 100
  // tests per UrlMap. Not supported when the URL map is bound to a target gRPC
  // proxy that has validateForProxyless field set to true.
  repeated UrlMapTest tests = 15 [json_name = "tests"];
}

// Contains a list of UrlMap resources.
message UrlMapList {
  // [Output Only] Unique identifier for the resource; defined by the server.
  optional string id = 1 [json_name = "id"];

  // A list of UrlMap resources.
  repeated UrlMap items = 2 [json_name = "items"];

  // Type of resource.
  optional string kind = 3 [json_name = "kind"];

  // [Output Only] This token allows you to get the next page of results for
  // list requests. If the number of results is larger than maxResults, use the
  // nextPageToken as a value for the query parameter pageToken in the next list
  // request. Subsequent list requests will have their own nextPageToken to
  // continue paging through the results.
  optional string next_page_token = 4 [json_name = "nextPageToken"];

  // [Output Only] Server-defined URL for this resource.
  optional string self_link = 5 [json_name = "selfLink"];

  message Warning {
    // [Output Only] A warning code, if applicable. For example, Compute Engine
    // returns NO_RESULTS_ON_PAGE if there are no results in the response.
    // CLEANUP_FAILED: Warning about failed cleanup of transient changes made by
    // a failed operation.
    // DEPRECATED_RESOURCE_USED: A link to a deprecated resource was created.
    // DEPRECATED_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as deprecated
    // DISK_SIZE_LARGER_THAN_IMAGE_SIZE: The user created a boot disk that is
    // larger than image size.
    // EXPERIMENTAL_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as experimental
    // EXTERNAL_API_WARNING: Warning that is present in an external api call
    // FIELD_VALUE_OVERRIDEN: Warning that value of a field has been overridden.
    // Deprecated unused field.
    // INJECTED_KERNELS_DEPRECATED: The operation involved use of an injected
    // kernel, which is deprecated.
    // INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB: A WEIGHTED_MAGLEV backend
    // service is associated with a health check that is not of type
    // HTTP/HTTPS/HTTP2.
    // LARGE_DEPLOYMENT_WARNING: When deploying a deployment with a exceedingly
    // large number of resources
    // LIST_OVERHEAD_QUOTA_EXCEED: Resource can't be retrieved due to list
    // overhead quota exceed which captures the amount of resources filtered out
    // by user-defined list filter.
    // MISSING_TYPE_DEPENDENCY: A resource depends on a missing type
    // NEXT_HOP_ADDRESS_NOT_ASSIGNED: The route's nextHopIp address is not
    // assigned to an instance on the network.
    // NEXT_HOP_CANNOT_IP_FORWARD: The route's next hop instance cannot ip
    // forward.
    // NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE: The route's nextHopInstance URL
    // refers to an instance that does not have an ipv6 interface on the same
    // network as the route.
    // NEXT_HOP_INSTANCE_NOT_FOUND: The route's nextHopInstance URL refers to an
    // instance that does not exist.
    // NEXT_HOP_INSTANCE_NOT_ON_NETWORK: The route's nextHopInstance URL refers
    // to an instance that is not on the same network as the route.
    // NEXT_HOP_NOT_RUNNING: The route's next hop instance does not have a
    // status of RUNNING.
    // NOT_CRITICAL_ERROR: Error which is not critical. We decided to continue
    // the process despite the mentioned error.
    // NO_RESULTS_ON_PAGE: No results are present on a particular list page.
    // PARTIAL_SUCCESS: Success is reported, but some results may be missing due
    // to errors
    // REQUIRED_TOS_AGREEMENT: The user attempted to use a resource that
    // requires a TOS they have not accepted.
    // RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING: Warning that a resource is in
    // use.
    // RESOURCE_NOT_DELETED: One or more of the resources set to auto-delete
    // could not be deleted because they were in use.
    // SCHEMA_VALIDATION_IGNORED: When a resource schema validation is ignored.
    // SINGLE_INSTANCE_PROPERTY_TEMPLATE: Instance template used in instance
    // group manager is valid as such, but its application does not make a lot
    // of sense, because it allows only single instance in instance group.
    // UNDECLARED_PROPERTIES: When undeclared properties in the schema are
    // present
    // UNREACHABLE: A given scope cannot be reached.
    optional string code = 1 [json_name = "code"];

    message DataItem {
      // [Output Only] A key that provides more detail on the warning being
      // returned. For example, for warnings where there are no results in a
      // list request for a particular zone, this key might be scope and the key
      // value might be the zone name. Other examples might be a key indicating
      // a deprecated resource and a suggested replacement, or a warning about
      // invalid network settings (for example, if an instance attempts to
      // perform IP forwarding but is not enabled for IP forwarding).
      optional string key = 1 [json_name = "key"];

      // [Output Only] A warning data value corresponding to the key.
      optional string value = 2 [json_name = "value"];
    }

    // [Output Only] Metadata about this warning in key: value format. For
    // example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    repeated DataItem data = 2 [json_name = "data"];

    // [Output Only] A human-readable description of the warning code.
    optional string message = 3 [json_name = "message"];
  }

  // [Output Only] Informational warning message.
  optional Warning warning = 6 [json_name = "warning"];
}

// Message for the expected URL mappings.
message UrlMapTest {
  // Description of this test case.
  optional string description = 1 [json_name = "description"];

  // The expected output URL evaluated by the load balancer containing the
  // scheme, host, path and query parameters. For rules that forward requests to
  // backends, the test passes only when expectedOutputUrl matches the request
  // forwarded by the load balancer to backends. For rules with urlRewrite, the
  // test verifies that the forwarded request matches hostRewrite and
  // pathPrefixRewrite in the urlRewrite action. When service is specified,
  // expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test
  // passes only if expectedOutputUrl matches the URL in the load balancer's
  // redirect response. If urlRedirect specifies https_redirect, the test passes
  // only if the scheme in expectedOutputUrl is also set to HTTPS. If
  // urlRedirect specifies strip_query, the test passes only if
  // expectedOutputUrl does not contain any query parameters. expectedOutputUrl
  // is optional when service is specified.
  optional string expected_output_url = 2 [json_name = "expectedOutputUrl"];

  // For rules with urlRedirect, the test passes only if
  // expectedRedirectResponseCode matches the HTTP status code in load
  // balancer's redirect response. expectedRedirectResponseCode cannot be set
  // when service is set.
  optional int32 expected_redirect_response_code = 3
      [json_name = "expectedRedirectResponseCode"];

  // HTTP headers for this request. If headers contains a host header, then host
  // must also match the header value.
  repeated UrlMapTestHeader headers = 4 [json_name = "headers"];

  // Host portion of the URL. If headers contains a host header, then host must
  // also match the header value.
  optional string host = 5 [json_name = "host"];

  // Path portion of the URL.
  optional string path = 6 [json_name = "path"];

  // Expected BackendService or BackendBucket resource the given URL should be
  // mapped to. The service field cannot be set if expectedRedirectResponseCode
  // is set.
  optional string service = 7 [json_name = "service"];
}

// HTTP headers used in UrlMapTests.
message UrlMapTestHeader {
  // Header name.
  optional string name = 1 [json_name = "name"];

  // Header value.
  optional string value = 2 [json_name = "value"];
}

// Message representing the validation result for a UrlMap.
message UrlMapValidationResult {
  repeated string load_errors = 1 [json_name = "loadErrors"];

  // Whether the given UrlMap can be successfully loaded. If false, 'loadErrors'
  // indicates the reasons.
  optional bool load_succeeded = 2 [json_name = "loadSucceeded"];

  repeated TestFailure test_failures = 3 [json_name = "testFailures"];

  // If successfully loaded, this field indicates whether the test passed. If
  // false, 'testFailures's indicate the reason of failure.
  optional bool test_passed = 4 [json_name = "testPassed"];
}

message UrlMapsValidateResponse {
  optional UrlMapValidationResult result = 1 [json_name = "result"];
}

// The spec for modifying the path before sending the request to the matched
// backend service.
message UrlRewrite {
  // Before forwarding the request to the selected service, the request's host
  // header is replaced with contents of hostRewrite. The value must be from 1
  // to 255 characters.
  optional string host_rewrite = 1 [json_name = "hostRewrite"];

  // Before forwarding the request to the selected backend service, the matching
  // portion of the request's path is replaced by pathPrefixRewrite. The value
  // must be from 1 to 1024 characters.
  optional string path_prefix_rewrite = 2 [json_name = "pathPrefixRewrite"];

  //  If specified, the pattern rewrites the URL path (based on the :path
  // header) using the HTTP template syntax. A corresponding path_template_match
  // must be specified. Any template variables must exist in the
  // path_template_match field. - -At least one variable must be specified in
  // the path_template_match field - You can omit variables from the rewritten
  // URL - The * and ** operators cannot be matched unless they have a
  // corresponding variable name - e.g. {format=*} or {var=**}. For example, a
  // path_template_match of /static/{format=**} could be rewritten as
  // /static/content/{format} to prefix /content to the URL. Variables can also
  // be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be
  // rewritten as /content/{format}/{country}/{suffix}. At least one non-empty
  // routeRules[].matchRules[].path_template_match is required. Only one of
  // path_prefix_rewrite or path_template_rewrite may be specified.
  optional string path_template_rewrite = 3 [json_name = "pathTemplateRewrite"];
}

// In contrast to a single BackendService in HttpRouteAction to which all
// matching traffic is directed to, WeightedBackendService allows traffic to be
// split across multiple backend services. The volume of traffic for each
// backend service is proportional to the weight specified in each
// WeightedBackendService
message WeightedBackendService {
  // The full or partial URL to the default BackendService resource. Before
  // forwarding the request to backendService, the load balancer applies any
  // relevant headerActions specified as part of this backendServiceWeight.
  optional string backend_service = 1 [json_name = "backendService"];

  // Specifies changes to request and response headers that need to take effect
  // for the selected backendService. headerAction specified here take effect
  // before headerAction in the enclosing HttpRouteRule, PathMatcher and UrlMap.
  // headerAction is not supported for load balancers that have their
  // loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
  // bound to a target gRPC proxy that has validateForProxyless field set to
  // true.
  optional HttpHeaderAction header_action = 2 [json_name = "headerAction"];

  // Specifies the fraction of traffic sent to a backend service, computed as
  // weight / (sum of all weightedBackendService weights in routeAction) . The
  // selection of a backend service is determined only for new traffic. Once a
  // user's request has been directed to a backend service, subsequent requests
  // are sent to the same backend service as determined by the backend service's
  // session affinity policy. The value must be from 0 to 1000.
  optional uint32 weight = 3 [json_name = "weight"];
}
