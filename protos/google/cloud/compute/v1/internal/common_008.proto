// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the C++ microgenerator.
// If you make any local changes, they will be lost.
// file:///workspace/generator/discovery/compute_public_google_rest_v1.json
// revision: 20240220

syntax = "proto3";

package google.cloud.cpp.compute.v1;

import "google/cloud/compute/v1/internal/common_039.proto";

// Represents an Autoscaler resource. Google Compute Engine has two Autoscaler
// resources: * [Zonal](/compute/docs/reference/rest/v1/autoscalers) *
// [Regional](/compute/docs/reference/rest/v1/regionAutoscalers) Use autoscalers
// to automatically add or delete instances from a managed instance group
// according to your defined autoscaling policy. For more information, read
// Autoscaling Groups of Instances. For zonal managed instance groups resource,
// use the autoscaler resource. For regional managed instance groups, use the
// regionAutoscalers resource.
message Autoscaler {
  // The configuration parameters for the autoscaling algorithm. You can define
  // one or more signals for an autoscaler: cpuUtilization,
  // customMetricUtilizations, and loadBalancingUtilization. If none of these
  // are specified, the default will be to autoscale based on cpuUtilization to
  // 0.6 or 60%.
  optional AutoscalingPolicy autoscaling_policy = 1
      [json_name = "autoscalingPolicy"];

  // [Output Only] Creation timestamp in RFC3339 text format.
  optional string creation_timestamp = 2 [json_name = "creationTimestamp"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 3 [json_name = "description"];

  // [Output Only] The unique identifier for the resource. This identifier is
  // defined by the server.
  optional string id = 4 [json_name = "id"];

  // [Output Only] Type of the resource. Always compute#autoscaler for
  // autoscalers.
  optional string kind = 5 [json_name = "kind"];

  // Name of the resource. Provided by the client when the resource is created.
  // The name must be 1-63 characters long, and comply with RFC1035.
  // Specifically, the name must be 1-63 characters long and match the regular
  // expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  // must be a lowercase letter, and all following characters must be a dash,
  // lowercase letter, or digit, except the last character, which cannot be a
  // dash.
  optional string name = 6 [json_name = "name"];

  // [Output Only] Target recommended MIG size (number of instances) computed by
  // autoscaler. Autoscaler calculates the recommended MIG size even when the
  // autoscaling policy mode is different from ON. This field is empty when
  // autoscaler is not connected to an existing managed instance group or
  // autoscaler did not generate its prediction.
  optional int32 recommended_size = 7 [json_name = "recommendedSize"];

  // [Output Only] URL of the region where the instance group resides (for
  // autoscalers living in regional scope).
  optional string region = 8 [json_name = "region"];

  // [Output Only] Status information of existing scaling schedules.
  map<string, ScalingScheduleStatus> scaling_schedule_status = 9
      [json_name = "scalingScheduleStatus"];

  // [Output Only] Server-defined URL for the resource.
  optional string self_link = 10 [json_name = "selfLink"];

  // [Output Only] The status of the autoscaler configuration. Current set of
  // possible values: - PENDING: Autoscaler backend hasn't read new/updated
  // configuration. - DELETING: Configuration is being deleted. - ACTIVE:
  // Configuration is acknowledged to be effective. Some warnings might be
  // present in the statusDetails field. - ERROR: Configuration has errors.
  // Actionable for users. Details are present in the statusDetails field. New
  // values might be added in the future.
  // ACTIVE: Configuration is acknowledged to be effective
  // DELETING: Configuration is being deleted
  // ERROR: Configuration has errors. Actionable for users.
  // PENDING: Autoscaler backend hasn't read new/updated configuration
  optional string status = 11 [json_name = "status"];

  // [Output Only] Human-readable details about the current state of the
  // autoscaler. Read the documentation for Commonly returned status messages
  // for examples of status messages you might encounter.
  repeated AutoscalerStatusDetails status_details = 12
      [json_name = "statusDetails"];

  // URL of the managed instance group that this autoscaler will scale. This
  // field is required when creating an autoscaler.
  optional string target = 13 [json_name = "target"];

  // [Output Only] URL of the zone where the instance group resides (for
  // autoscalers living in zonal scope).
  optional string zone = 14 [json_name = "zone"];
}

message AutoscalerStatusDetails {
  // The status message.
  optional string message = 1 [json_name = "message"];

  // The type of error, warning, or notice returned. Current set of possible
  // values: - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance
  // group are unhealthy (not in RUNNING state). -
  // BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
  // attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING):
  // Autoscaler recommends a size greater than maxNumReplicas. -
  // CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples
  // are not exported often enough to be a credible base for autoscaling. -
  // CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does
  // not exist or does not have the necessary labels. - MIN_EQUALS_MAX
  // (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the
  // autoscaler cannot add or remove instances from the instance group. -
  // MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not receive
  // any data from the custom metric configured for autoscaling. -
  // MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured
  // to scale based on a load balancing signal but the instance group has not
  // received any requests from the load balancer. - MODE_OFF (WARNING):
  // Autoscaling is turned off. The number of instances in the group won't
  // change automatically. The autoscaling configuration is preserved. -
  // MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode.
  // The autoscaler can add instances but not remove any. -
  // MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be
  // autoscaled because it has more than one backend service attached to it. -
  // NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the
  // necessary resources, such as CPU or number of instances. -
  // REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers:
  // there is a resource stockout in the chosen region. -
  // SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
  // exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR):
  // Autoscaling does not work with an HTTP/S load balancer that has been
  // configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal
  // autoscalers: there is a resource stockout in the chosen zone. For regional
  // autoscalers: in at least one of the zones you're using there is a resource
  // stockout. New values might be added in the future. Some of the values might
  // not be available in all API versions.
  // ALL_INSTANCES_UNHEALTHY: All instances in the instance group are unhealthy
  // (not in RUNNING state).
  // BACKEND_SERVICE_DOES_NOT_EXIST: There is no backend service attached to the
  // instance group.
  // CAPPED_AT_MAX_NUM_REPLICAS: Autoscaler recommends a size greater than
  // maxNumReplicas.
  // CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE: The custom metric samples are not
  // exported often enough to be a credible base for autoscaling.
  // CUSTOM_METRIC_INVALID: The custom metric that was specified does not exist
  // or does not have the necessary labels.
  // MIN_EQUALS_MAX: The minNumReplicas is equal to maxNumReplicas. This means
  // the autoscaler cannot add or remove instances from the instance group.
  // MISSING_CUSTOM_METRIC_DATA_POINTS: The autoscaler did not receive any data
  // from the custom metric configured for autoscaling.
  // MISSING_LOAD_BALANCING_DATA_POINTS: The autoscaler is configured to scale
  // based on a load balancing signal but the instance group has not received
  // any requests from the load balancer.
  // MODE_OFF: Autoscaling is turned off. The number of instances in the group
  // won't change automatically. The autoscaling configuration is preserved.
  // MODE_ONLY_SCALE_OUT: Autoscaling is in the "Autoscale only scale out" mode.
  // Instances in the group will be only added.
  // MODE_ONLY_UP: Autoscaling is in the "Autoscale only out" mode. Instances in
  // the group will be only added.
  // MORE_THAN_ONE_BACKEND_SERVICE: The instance group cannot be autoscaled
  // because it has more than one backend service attached to it.
  // NOT_ENOUGH_QUOTA_AVAILABLE: There is insufficient quota for the necessary
  // resources, such as CPU or number of instances.
  // REGION_RESOURCE_STOCKOUT: Showed only for regional autoscalers: there is a
  // resource stockout in the chosen region.
  // SCALING_TARGET_DOES_NOT_EXIST: The target to be scaled does not exist.
  // SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX: For some scaling schedules
  // minRequiredReplicas is greater than maxNumReplicas. Autoscaler always
  // recommends at most maxNumReplicas instances.
  // SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN: For some scaling schedules
  // minRequiredReplicas is less than minNumReplicas. Autoscaler always
  // recommends at least minNumReplicas instances.
  // UNKNOWN:
  // UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION: Autoscaling does not
  // work with an HTTP/S load balancer that has been configured for maxRate.
  // ZONE_RESOURCE_STOCKOUT: For zonal autoscalers: there is a resource stockout
  // in the chosen zone. For regional autoscalers: in at least one of the zones
  // you're using there is a resource stockout.
  optional string type = 2 [json_name = "type"];
}

// Cloud Autoscaler policy.
message AutoscalingPolicy {
  // The number of seconds that your application takes to initialize on a VM
  // instance. This is referred to as the [initialization
  // period](/compute/docs/autoscaler#cool_down_period). Specifying an accurate
  // initialization period improves autoscaler decisions. For example, when
  // scaling out, the autoscaler ignores data from VMs that are still
  // initializing because those VMs might not yet represent normal usage of your
  // application. The default initialization period is 60 seconds.
  // Initialization periods might vary because of numerous factors. We recommend
  // that you test how long your application takes to initialize. To do this,
  // create a VM and time your application's startup process.
  optional int32 cool_down_period_sec = 1 [json_name = "coolDownPeriodSec"];

  // Defines the CPU utilization policy that allows the autoscaler to scale
  // based on the average CPU utilization of a managed instance group.
  optional AutoscalingPolicyCpuUtilization cpu_utilization = 2
      [json_name = "cpuUtilization"];

  // Configuration parameters of autoscaling based on a custom metric.
  repeated AutoscalingPolicyCustomMetricUtilization custom_metric_utilizations =
      3 [json_name = "customMetricUtilizations"];

  // Configuration parameters of autoscaling based on load balancer.
  optional AutoscalingPolicyLoadBalancingUtilization
      load_balancing_utilization = 4 [json_name = "loadBalancingUtilization"];

  // The maximum number of instances that the autoscaler can scale out to. This
  // is required when creating or updating an autoscaler. The maximum number of
  // replicas must not be lower than minimal number of replicas.
  optional int32 max_num_replicas = 5 [json_name = "maxNumReplicas"];

  // The minimum number of replicas that the autoscaler can scale in to. This
  // cannot be less than 0. If not provided, autoscaler chooses a default value
  // depending on maximum number of instances allowed.
  optional int32 min_num_replicas = 6 [json_name = "minNumReplicas"];

  // Defines the operating mode for this policy. The following modes are
  // available: - OFF: Disables the autoscaler but maintains its configuration.
  // - ONLY_SCALE_OUT: Restricts the autoscaler to add VM instances only. - ON:
  // Enables all autoscaler activities according to its policy. For more
  // information, see "Turning off or restricting an autoscaler"
  // OFF: Do not automatically scale the MIG in or out. The recommended_size
  // field contains the size of MIG that would be set if the actuation mode was
  // enabled.
  // ON: Automatically scale the MIG in and out according to the policy.
  // ONLY_SCALE_OUT: Automatically create VMs according to the policy, but do
  // not scale the MIG in.
  // ONLY_UP: Automatically create VMs according to the policy, but do not scale
  // the MIG in.
  optional string mode = 7 [json_name = "mode"];

  optional AutoscalingPolicyScaleInControl scale_in_control = 8
      [json_name = "scaleInControl"];

  // Scaling schedules defined for an autoscaler. Multiple schedules can be set
  // on an autoscaler, and they can overlap. During overlapping periods the
  // greatest min_required_replicas of all scaling schedules is applied. Up to
  // 128 scaling schedules are allowed.
  map<string, AutoscalingPolicyScalingSchedule> scaling_schedules = 9
      [json_name = "scalingSchedules"];
}

// CPU utilization policy.
message AutoscalingPolicyCpuUtilization {
  // Indicates whether predictive autoscaling based on CPU metric is enabled.
  // Valid values are: * NONE (default). No predictive method is used. The
  // autoscaler scales the group to meet current demand based on real-time
  // metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves
  // availability by monitoring daily and weekly load patterns and scaling out
  // ahead of anticipated demand.
  // NONE: No predictive method is used. The autoscaler scales the group to meet
  // current demand based on real-time metrics
  // OPTIMIZE_AVAILABILITY: Predictive autoscaling improves availability by
  // monitoring daily and weekly load patterns and scaling out ahead of
  // anticipated demand.
  optional string predictive_method = 1 [json_name = "predictiveMethod"];

  // The target CPU utilization that the autoscaler maintains. Must be a float
  // value in the range (0, 1]. If not specified, the default is 0.6. If the CPU
  // level is below the target utilization, the autoscaler scales in the number
  // of instances until it reaches the minimum number of instances you specified
  // or until the average CPU of your instances reaches the target utilization.
  // If the average CPU is above the target utilization, the autoscaler scales
  // out until it reaches the maximum number of instances you specified or until
  // the average utilization reaches the target utilization.
  optional double utilization_target = 2 [json_name = "utilizationTarget"];
}

// Custom utilization metric policy.
message AutoscalingPolicyCustomMetricUtilization {
  // A filter string, compatible with a Stackdriver Monitoring filter string for
  // TimeSeries.list API call. This filter is used to select a specific
  // TimeSeries for the purpose of autoscaling and to determine whether the
  // metric is exporting per-instance or per-group data. For the filter to be
  // valid for autoscaling purposes, the following rules apply: - You can only
  // use the AND operator for joining selectors. - You can only use direct
  // equality comparison operator (=) without any functions for each selector. -
  // You can specify the metric in both the filter string and in the metric
  // field. However, if specified in both places, the metric must be identical.
  // - The monitored resource type determines what kind of values are expected
  // for the metric. If it is a gce_instance, the autoscaler expects the metric
  // to include a separate TimeSeries for each instance in a group. In such a
  // case, you cannot filter on resource labels. If the resource type is any
  // other value, the autoscaler expects this metric to contain values that
  // apply to the entire autoscaled instance group and resource label filtering
  // can be performed to point autoscaler at the correct TimeSeries to scale
  // upon. This is called a *per-group metric* for the purpose of autoscaling.
  // If not specified, the type defaults to gce_instance. Try to provide a
  // filter that is selective enough to pick just one TimeSeries for the
  // autoscaled group or for each of the instances (if you are using
  // gce_instance resource type). If multiple TimeSeries are returned upon the
  // query execution, the autoscaler will sum their respective values to obtain
  // its scaling value.
  optional string filter = 1 [json_name = "filter"];

  // The identifier (type) of the Stackdriver Monitoring metric. The metric
  // cannot have negative values. The metric must have a value type of INT64 or
  // DOUBLE.
  optional string metric = 2 [json_name = "metric"];

  // If scaling is based on a per-group metric value that represents the total
  // amount of work to be done or resource usage, set this value to an amount
  // assigned for a single instance of the scaled group. Autoscaler keeps the
  // number of instances proportional to the value of this metric. The metric
  // itself does not change value due to group resizing. A good metric to use
  // with the target is for example
  // pubsub.googleapis.com/subscription/num_undelivered_messages or a custom
  // metric exporting the total number of requests coming to your instances. A
  // bad example would be a metric exporting an average or median latency, since
  // this value can't include a chunk assignable to a single instance, it could
  // be better used with utilization_target instead.
  optional double single_instance_assignment = 3
      [json_name = "singleInstanceAssignment"];

  // The target value of the metric that autoscaler maintains. This must be a
  // positive value. A utilization metric scales number of virtual machines
  // handling requests to increase or decrease proportionally to the metric. For
  // example, a good metric to use as a utilization_target is
  // https://www.googleapis.com/compute/v1/instance/network/received_bytes_count.
  // The autoscaler works to keep this value constant for each of the instances.
  optional double utilization_target = 4 [json_name = "utilizationTarget"];

  // Defines how target utilization value is expressed for a Stackdriver
  // Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
  // DELTA_PER_MINUTE: Sets the utilization target value for a cumulative or
  // delta metric, expressed as the rate of growth per minute.
  // DELTA_PER_SECOND: Sets the utilization target value for a cumulative or
  // delta metric, expressed as the rate of growth per second.
  // GAUGE: Sets the utilization target value for a gauge metric. The autoscaler
  // will collect the average utilization of the virtual machines from the last
  // couple of minutes, and compare the value to the utilization target value to
  // perform autoscaling.
  optional string utilization_target_type = 5
      [json_name = "utilizationTargetType"];
}

// Configuration parameters of autoscaling based on load balancing.
message AutoscalingPolicyLoadBalancingUtilization {
  // Fraction of backend capacity utilization (set in HTTP(S) load balancing
  // configuration) that the autoscaler maintains. Must be a positive float
  // value. If not defined, the default is 0.8.
  optional double utilization_target = 1 [json_name = "utilizationTarget"];
}

// Configuration that allows for slower scale in so that even if Autoscaler
// recommends an abrupt scale in of a MIG, it will be throttled as specified by
// the parameters below.
message AutoscalingPolicyScaleInControl {
  // Maximum allowed number (or %) of VMs that can be deducted from the peak
  // recommendation during the window autoscaler looks at when computing
  // recommendations. Possibly all these VMs can be deleted at once so user
  // service needs to be prepared to lose that many VMs in one step.
  optional FixedOrPercent max_scaled_in_replicas = 1
      [json_name = "maxScaledInReplicas"];

  // How far back autoscaling looks when computing recommendations to include
  // directives regarding slower scale in, as described above.
  optional int32 time_window_sec = 2 [json_name = "timeWindowSec"];
}

// Scaling based on user-defined schedule. The message describes a single
// scaling schedule. A scaling schedule changes the minimum number of VM
// instances an autoscaler can recommend, which can trigger scaling out.
message AutoscalingPolicyScalingSchedule {
  // A description of a scaling schedule.
  optional string description = 1 [json_name = "description"];

  // A boolean value that specifies whether a scaling schedule can influence
  // autoscaler recommendations. If set to true, then a scaling schedule has no
  // effect. This field is optional, and its value is false by default.
  optional bool disabled = 2 [json_name = "disabled"];

  // The duration of time intervals, in seconds, for which this scaling schedule
  // is to run. The minimum allowed value is 300. This field is required.
  optional int32 duration_sec = 3 [json_name = "durationSec"];

  // The minimum number of VM instances that the autoscaler will recommend in
  // time intervals starting according to schedule. This field is required.
  optional int32 min_required_replicas = 4 [json_name = "minRequiredReplicas"];

  // The start timestamps of time intervals when this scaling schedule is to
  // provide a scaling signal. This field uses the extended cron format (with an
  // optional year field). The expression can describe a single timestamp if the
  // optional year is set, in which case the scaling schedule runs once. The
  // schedule is interpreted with respect to time_zone. This field is required.
  // Note: These timestamps only describe when autoscaler starts providing the
  // scaling signal. The VMs need additional time to become serving.
  optional string schedule = 5 [json_name = "schedule"];

  // The time zone to use when interpreting the schedule. The value of this
  // field must be a time zone name from the tz database:
  // https://en.wikipedia.org/wiki/Tz_database. This field is assigned a default
  // value of "UTC" if left empty.
  optional string time_zone = 6 [json_name = "timeZone"];
}

message ScalingScheduleStatus {
  // [Output Only] The last time the scaling schedule became active. Note: this
  // is a timestamp when a schedule actually became active, not when it was
  // planned to do so. The timestamp is in RFC3339 text format.
  optional string last_start_time = 1 [json_name = "lastStartTime"];

  // [Output Only] The next time the scaling schedule is to become active. Note:
  // this is a timestamp when a schedule is planned to run, but the actual time
  // might be slightly different. The timestamp is in RFC3339 text format.
  optional string next_start_time = 2 [json_name = "nextStartTime"];

  // [Output Only] The current state of a scaling schedule.
  // ACTIVE: The current autoscaling recommendation is influenced by this
  // scaling schedule.
  // DISABLED: This scaling schedule has been disabled by the user.
  // OBSOLETE: This scaling schedule will never become active again.
  // READY: The current autoscaling recommendation is not influenced by this
  // scaling schedule.
  optional string state = 3 [json_name = "state"];
}
