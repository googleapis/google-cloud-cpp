// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the C++ microgenerator.
// If you make any local changes, they will be lost.
// file:///workspace/generator/discovery/compute_public_google_rest_v1.json
// revision: 20250302

syntax = "proto3";

package google.cloud.cpp.compute.v1;

import "google/cloud/compute/v1/internal/common_029.proto";
import "google/cloud/compute/v1/internal/common_051.proto";

// Contains the configurations necessary to generate a signature for access to
// private storage buckets that support Signature Version 4 for authentication.
// The service name for generating the authentication header will always default
// to 's3'.
message AWSV4Signature {
  // The access key used for s3 bucket authentication. Required for updating or
  // creating a backend that uses AWS v4 signature authentication, but will not
  // be returned as part of the configuration when queried with a REST API GET
  // request. @InputOnly
  optional string access_key = 1 [json_name = "accessKey"];

  // The identifier of an access key used for s3 bucket authentication.
  optional string access_key_id = 2 [json_name = "accessKeyId"];

  // The optional version identifier for the access key. You can use this to
  // keep track of different iterations of your access key.
  optional string access_key_version = 3 [json_name = "accessKeyVersion"];

  // The name of the cloud region of your origin. This is a free-form field with
  // the name of the region your cloud uses to host your origin. For example,
  // "us-east-1" for AWS or "us-ashburn-1" for OCI.
  optional string origin_region = 4 [json_name = "originRegion"];
}

// Message containing information of one individual backend.
message Backend {
  // Specifies how to determine whether the backend of a load balancer can
  // handle additional traffic or is fully loaded. For usage guidelines, see
  // Connection balancing mode. Backends must use compatible balancing modes.
  // For more information, see Supported balancing modes and target capacity
  // settings and Restrictions and guidance for instance groups. Note:
  // Currently, if you use the API to configure incompatible balancing modes,
  // the configuration might be accepted even though it has no impact and is
  // ignored. Specifically, Backend.maxUtilization is ignored when
  // Backend.balancingMode is RATE. In the future, this incompatible combination
  // will be rejected.
  // CONNECTION: Balance based on the number of simultaneous connections.
  // CUSTOM_METRICS: Based on custom defined and reported metrics.
  // RATE: Balance based on requests per second (RPS).
  // UTILIZATION: Balance based on the backend utilization.
  optional string balancing_mode = 1 [json_name = "balancingMode"];

  // A multiplier applied to the backend's target capacity of its balancing
  // mode. The default value is 1, which means the group serves up to 100% of
  // its configured capacity (depending on balancingMode). A setting of 0 means
  // the group is completely drained, offering 0% of its available capacity. The
  // valid ranges are 0.0 and [0.1,1.0]. You cannot configure a setting larger
  // than 0 and smaller than 0.1. You cannot configure a setting of 0 when there
  // is only one backend attached to the backend service. Not available with
  // backends that don't support using a balancingMode. This includes backends
  // such as global internet NEGs, regional serverless NEGs, and PSC NEGs.
  optional float capacity_scaler = 2 [json_name = "capacityScaler"];

  // List of custom metrics that are used for CUSTOM_METRICS BalancingMode.
  repeated BackendCustomMetric custom_metrics = 14
      [json_name = "customMetrics"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 3 [json_name = "description"];

  // This field designates whether this is a failover backend. More than one
  // failover backend can be configured for a given BackendService.
  optional bool failover = 4 [json_name = "failover"];

  // The fully-qualified URL of an instance group or network endpoint group
  // (NEG) resource. To determine what types of backends a load balancer
  // supports, see the [Backend services
  // overview](https://cloud.google.com/load-balancing/docs/backend-service#backends).
  // You must use the *fully-qualified* URL (starting with
  // https://www.googleapis.com/) to specify the instance group or NEG. Partial
  // URLs are not supported.
  optional string group = 5 [json_name = "group"];

  // Defines a target maximum number of simultaneous connections. For usage
  // guidelines, see Connection balancing mode and Utilization balancing mode.
  // Not available if the backend's balancingMode is RATE.
  optional int32 max_connections = 6 [json_name = "maxConnections"];

  // Defines a target maximum number of simultaneous connections. For usage
  // guidelines, see Connection balancing mode and Utilization balancing mode.
  // Not available if the backend's balancingMode is RATE.
  optional int32 max_connections_per_endpoint = 7
      [json_name = "maxConnectionsPerEndpoint"];

  // Defines a target maximum number of simultaneous connections. For usage
  // guidelines, see Connection balancing mode and Utilization balancing mode.
  // Not available if the backend's balancingMode is RATE.
  optional int32 max_connections_per_instance = 8
      [json_name = "maxConnectionsPerInstance"];

  // Defines a maximum number of HTTP requests per second (RPS). For usage
  // guidelines, see Rate balancing mode and Utilization balancing mode. Not
  // available if the backend's balancingMode is CONNECTION.
  optional int32 max_rate = 9 [json_name = "maxRate"];

  // Defines a maximum target for requests per second (RPS). For usage
  // guidelines, see Rate balancing mode and Utilization balancing mode. Not
  // available if the backend's balancingMode is CONNECTION.
  optional float max_rate_per_endpoint = 10 [json_name = "maxRatePerEndpoint"];

  // Defines a maximum target for requests per second (RPS). For usage
  // guidelines, see Rate balancing mode and Utilization balancing mode. Not
  // available if the backend's balancingMode is CONNECTION.
  optional float max_rate_per_instance = 11 [json_name = "maxRatePerInstance"];

  // Optional parameter to define a target capacity for the UTILIZATION
  // balancing mode. The valid range is [0.0, 1.0]. For usage guidelines, see
  // Utilization balancing mode.
  optional float max_utilization = 12 [json_name = "maxUtilization"];

  // This field indicates whether this backend should be fully utilized before
  // sending traffic to backends with default preference. The possible values
  // are: - PREFERRED: Backends with this preference level will be filled up to
  // their capacity limits first, based on RTT. - DEFAULT: If preferred backends
  // don't have enough capacity, backends in this layer would be used and
  // traffic would be assigned based on the load balancing algorithm you use.
  // This is the default
  // DEFAULT: No preference.
  // PREFERENCE_UNSPECIFIED: If preference is unspecified, we set it to the
  // DEFAULT value
  // PREFERRED: Traffic will be sent to this backend first.
  optional string preference = 13 [json_name = "preference"];
}

// Custom Metrics are used for CUSTOM_METRICS balancing_mode.
message BackendCustomMetric {
  // If true, the metric data is collected and reported to Cloud Monitoring, but
  // is not used for load balancing.
  optional bool dry_run = 1 [json_name = "dryRun"];

  // Optional parameter to define a target utilization for the Custom Metrics
  // balancing mode. The valid range is [0.0, 1.0].
  optional float max_utilization = 2 [json_name = "maxUtilization"];

  // Name of a custom utilization signal. The name must be 1-64 characters long
  // and match the regular expression [a-z]([-_.a-z0-9]*[a-z0-9])? which means
  // the first character must be a lowercase letter, and all following
  // characters must be a dash, period, underscore, lowercase letter, or digit,
  // except the last character, which cannot be a dash, period, or underscore.
  // For usage guidelines, see Custom Metrics balancing mode. This field can
  // only be used for a global or regional backend service with the
  // loadBalancingScheme set to EXTERNAL_MANAGED, INTERNAL_MANAGED
  // INTERNAL_SELF_MANAGED.
  optional string name = 3 [json_name = "name"];
}

// Represents a Backend Service resource. A backend service defines how Google
// Cloud load balancers distribute traffic. The backend service configuration
// contains a set of values, such as the protocol used to connect to backends,
// various distribution and session settings, health checks, and timeouts. These
// settings provide fine-grained control over how your load balancer behaves.
// Most of the settings have default values that allow for easy configuration if
// you need to get started quickly. Backend services in Google Compute Engine
// can be either regionally or globally scoped. *
// [Global](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices)
// *
// [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/regionBackendServices)
// For more information, see Backend Services.
message BackendService {
  // Lifetime of cookies in seconds. This setting is applicable to Application
  // Load Balancers and Traffic Director and requires GENERATED_COOKIE or
  // HTTP_COOKIE session affinity. If set to 0, the cookie is non-persistent and
  // lasts only until the end of the browser session (or equivalent). The
  // maximum allowed value is two weeks (1,209,600). Not supported when the
  // backend service is referenced by a URL map that is bound to target gRPC
  // proxy that has validateForProxyless field set to true.
  optional int32 affinity_cookie_ttl_sec = 1
      [json_name = "affinityCookieTtlSec"];

  // The list of backends that serve this BackendService.
  repeated Backend backends = 2 [json_name = "backends"];

  // Cloud CDN configuration for this BackendService. Only available for
  // specified load balancer types.
  optional BackendServiceCdnPolicy cdn_policy = 3 [json_name = "cdnPolicy"];

  optional CircuitBreakers circuit_breakers = 4 [json_name = "circuitBreakers"];

  // Compress text responses using Brotli or gzip compression, based on the
  // client's Accept-Encoding header.
  // AUTOMATIC: Automatically uses the best compression based on the
  // Accept-Encoding header sent by the client.
  // DISABLED: Disables compression. Existing compressed responses cached by
  // Cloud CDN will not be served to clients.
  optional string compression_mode = 5 [json_name = "compressionMode"];

  optional ConnectionDraining connection_draining = 6
      [json_name = "connectionDraining"];

  // Connection Tracking configuration for this BackendService. Connection
  // tracking policy settings are only available for external passthrough
  // Network Load Balancers and internal passthrough Network Load Balancers.
  optional BackendServiceConnectionTrackingPolicy connection_tracking_policy = 7
      [json_name = "connectionTrackingPolicy"];

  // Consistent Hash-based load balancing can be used to provide soft session
  // affinity based on HTTP headers, cookies or other properties. This load
  // balancing policy is applicable only for HTTP connections. The affinity to a
  // particular destination host will be lost when one or more hosts are
  // added/removed from the destination service. This field specifies parameters
  // that control consistent hashing. This field is only applicable when
  // localityLbPolicy is set to MAGLEV or RING_HASH. This field is applicable to
  // either: - A regional backend service with the service_protocol set to HTTP,
  // HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A
  // global backend service with the load_balancing_scheme set to
  // INTERNAL_SELF_MANAGED.
  optional ConsistentHashLoadBalancerSettings consistent_hash = 8
      [json_name = "consistentHash"];

  // [Output Only] Creation timestamp in RFC3339 text format.
  optional string creation_timestamp = 9 [json_name = "creationTimestamp"];

  // List of custom metrics that are used for the WEIGHTED_ROUND_ROBIN
  // locality_lb_policy.
  repeated BackendServiceCustomMetric custom_metrics = 45
      [json_name = "customMetrics"];

  // Headers that the load balancer adds to proxied requests. See [Creating
  // custom
  // headers](https://cloud.google.com/load-balancing/docs/custom-headers).
  repeated string custom_request_headers = 10
      [json_name = "customRequestHeaders"];

  // Headers that the load balancer adds to proxied responses. See [Creating
  // custom
  // headers](https://cloud.google.com/load-balancing/docs/custom-headers).
  repeated string custom_response_headers = 11
      [json_name = "customResponseHeaders"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 12 [json_name = "description"];

  // [Output Only] The resource URL for the edge security policy associated with
  // this backend service.
  optional string edge_security_policy = 13 [json_name = "edgeSecurityPolicy"];

  // If true, enables Cloud CDN for the backend service of a global external
  // Application Load Balancer.
  optional bool enable_cdn = 14 [json_name = "enableCDN"];

  // Requires at least one backend instance group to be defined as a backup
  // (failover) backend. For load balancers that have configurable failover:
  // [Internal passthrough Network Load
  // Balancers](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  // and [external passthrough Network Load
  // Balancers](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
  optional BackendServiceFailoverPolicy failover_policy = 15
      [json_name = "failoverPolicy"];

  // Fingerprint of this resource. A hash of the contents stored in this object.
  // This field is used in optimistic locking. This field will be ignored when
  // inserting a BackendService. An up-to-date fingerprint must be provided in
  // order to update the BackendService, otherwise the request will fail with
  // error 412 conditionNotMet. To see the latest fingerprint, make a get()
  // request to retrieve a BackendService.
  optional string fingerprint = 16 [json_name = "fingerprint"];

  // The list of URLs to the healthChecks, httpHealthChecks (legacy), or
  // httpsHealthChecks (legacy) resource for health checking this backend
  // service. Not all backend services support legacy health checks. See Load
  // balancer guide. Currently, at most one health check can be specified for
  // each backend service. Backend services with instance group or zonal NEG
  // backends must have a health check. Backend services with internet or
  // serverless NEG backends must not have a health check.
  repeated string health_checks = 17 [json_name = "healthChecks"];

  // The configurations for Identity-Aware Proxy on this resource. Not available
  // for internal passthrough Network Load Balancers and external passthrough
  // Network Load Balancers.
  optional BackendServiceIAP iap = 18 [json_name = "iap"];

  // [Output Only] The unique identifier for the resource. This identifier is
  // defined by the server.
  optional string id = 19 [json_name = "id"];

  // Specifies a preference for traffic sent from the proxy to the backend (or
  // from the client to the backend for proxyless gRPC). The possible values
  // are: - IPV4_ONLY: Only send IPv4 traffic to the backends of the backend
  // service (Instance Group, Managed Instance Group, Network Endpoint Group),
  // regardless of traffic from the client to the proxy. Only IPv4 health checks
  // are used to check the health of the backends. This is the default setting.
  // - PREFER_IPV6: Prioritize the connection to the endpoint's IPv6 address
  // over its IPv4 address (provided there is a healthy IPv6 address). -
  // IPV6_ONLY: Only send IPv6 traffic to the backends of the backend service
  // (Instance Group, Managed Instance Group, Network Endpoint Group),
  // regardless of traffic from the client to the proxy. Only IPv6 health checks
  // are used to check the health of the backends. This field is applicable to
  // either: - Advanced global external Application Load Balancer (load
  // balancing scheme EXTERNAL_MANAGED), - Regional external Application Load
  // Balancer, - Internal proxy Network Load Balancer (load balancing scheme
  // INTERNAL_MANAGED), - Regional internal Application Load Balancer (load
  // balancing scheme INTERNAL_MANAGED), - Traffic Director with Envoy proxies
  // and proxyless gRPC (load balancing scheme INTERNAL_SELF_MANAGED).
  // IPV4_ONLY: Only send IPv4 traffic to the backends of the Backend Service
  // (Instance Group, Managed Instance Group, Network Endpoint Group) regardless
  // of traffic from the client to the proxy. Only IPv4 health-checks are used
  // to check the health of the backends. This is the default setting.
  // IPV6_ONLY: Only send IPv6 traffic to the backends of the Backend Service
  // (Instance Group, Managed Instance Group, Network Endpoint Group) regardless
  // of traffic from the client to the proxy. Only IPv6 health-checks are used
  // to check the health of the backends.
  // IP_ADDRESS_SELECTION_POLICY_UNSPECIFIED: Unspecified IP address selection
  // policy.
  // PREFER_IPV6: Prioritize the connection to the endpoints IPv6 address over
  // its IPv4 address (provided there is a healthy IPv6 address).
  optional string ip_address_selection_policy = 43
      [json_name = "ipAddressSelectionPolicy"];

  // [Output Only] Type of resource. Always compute#backendService for backend
  // services.
  optional string kind = 20 [json_name = "kind"];

  // Specifies the load balancer type. A backend service created for one type of
  // load balancer cannot be used with another. For more information, refer to
  // Choosing a load balancer.
  // EXTERNAL: Signifies that this will be used for classic Application Load
  // Balancers, global external proxy Network Load Balancers, or external
  // passthrough Network Load Balancers.
  // EXTERNAL_MANAGED: Signifies that this will be used for global external
  // Application Load Balancers, regional external Application Load Balancers,
  // or regional external proxy Network Load Balancers.
  // INTERNAL: Signifies that this will be used for internal passthrough Network
  // Load Balancers.
  // INTERNAL_MANAGED: Signifies that this will be used for internal Application
  // Load Balancers.
  // INTERNAL_SELF_MANAGED: Signifies that this will be used by Traffic
  // Director.
  // INVALID_LOAD_BALANCING_SCHEME:
  optional string load_balancing_scheme = 21
      [json_name = "loadBalancingScheme"];

  // A list of locality load-balancing policies to be used in order of
  // preference. When you use localityLbPolicies, you must set at least one
  // value for either the localityLbPolicies[].policy or the
  // localityLbPolicies[].customPolicy field. localityLbPolicies overrides any
  // value set in the localityLbPolicy field. For an example of how to use this
  // field, see Define a list of preferred policies. Caution: This field and its
  // children are intended for use in a service mesh that includes gRPC clients
  // only. Envoy proxies can't use backend services that have this
  // configuration.
  repeated BackendServiceLocalityLoadBalancingPolicyConfig
      locality_lb_policies = 22 [json_name = "localityLbPolicies"];

  // The load balancing algorithm used within the scope of the locality. The
  // possible values are: - ROUND_ROBIN: This is a simple policy in which each
  // healthy backend is selected in round robin order. This is the default. -
  // LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and
  // picks the host which has fewer active requests. - RING_HASH: The
  // ring/modulo hash load balancer implements consistent hashing to backends.
  // The algorithm has the property that the addition/removal of a host from a
  // set of N hosts only affects 1/N of the requests. - RANDOM: The load
  // balancer selects a random healthy host. - ORIGINAL_DESTINATION: Backend
  // host is selected based on the client connection metadata, i.e., connections
  // are opened to the same address as the destination address of the incoming
  // connection before the connection was redirected to the load balancer. -
  // MAGLEV: used as a drop in replacement for the ring hash load balancer.
  // Maglev is not as stable as ring hash but has faster table lookup build
  // times and host selection times. For more information about Maglev, see
  // https://ai.google/research/pubs/pub44824 This field is applicable to
  // either: - A regional backend service with the service_protocol set to HTTP,
  // HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A
  // global backend service with the load_balancing_scheme set to
  // INTERNAL_SELF_MANAGED, INTERNAL_MANAGED, or EXTERNAL_MANAGED. If
  // sessionAffinity is not configured—that is, if session affinity remains at
  // the default value of NONE—then the default value for localityLbPolicy is
  // ROUND_ROBIN. If session affinity is set to a value other than NONE, then
  // the default value for localityLbPolicy is MAGLEV. Only ROUND_ROBIN and
  // RING_HASH are supported when the backend service is referenced by a URL map
  // that is bound to target gRPC proxy that has validateForProxyless field set
  // to true.
  // INVALID_LB_POLICY:
  // LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and
  // picks the host which has fewer active requests.
  // MAGLEV: This algorithm implements consistent hashing to backends. Maglev
  // can be used as a drop in replacement for the ring hash load balancer.
  // Maglev is not as stable as ring hash but has faster table lookup build
  // times and host selection times. For more information about Maglev, see
  // https://ai.google/research/pubs/pub44824
  // ORIGINAL_DESTINATION: Backend host is selected based on the client
  // connection metadata, i.e., connections are opened to the same address as
  // the destination address of the incoming connection before the connection
  // was redirected to the load balancer.
  // RANDOM: The load balancer selects a random healthy host.
  // RING_HASH: The ring/modulo hash load balancer implements consistent hashing
  // to backends. The algorithm has the property that the addition/removal of a
  // host from a set of N hosts only affects 1/N of the requests.
  // ROUND_ROBIN: This is a simple policy in which each healthy backend is
  // selected in round robin order. This is the default.
  // WEIGHTED_MAGLEV: Per-instance weighted Load Balancing via health check
  // reported weights. If set, the Backend Service must configure a non legacy
  // HTTP-based Health Check, and health check replies are expected to contain
  // non-standard HTTP response header field X-Load-Balancing-Endpoint-Weight to
  // specify the per-instance weights. If set, Load Balancing is weighted based
  // on the per-instance weights reported in the last processed health check
  // replies, as long as every instance either reported a valid weight or had
  // UNAVAILABLE_WEIGHT. Otherwise, Load Balancing remains equal-weight. This
  // option is only supported in Network Load Balancing.
  // WEIGHTED_ROUND_ROBIN: Per-endpoint weighted round-robin Load Balancing
  // using weights computed from Backend reported Custom Metrics. If set, the
  // Backend Service responses are expected to contain non-standard HTTP
  // response header field X-Endpoint-Load-Metrics. The reported metrics to use
  // for computing the weights are specified via the backends[].customMetrics
  // fields.
  optional string locality_lb_policy = 23 [json_name = "localityLbPolicy"];

  // This field denotes the logging options for the load balancer traffic served
  // by this backend service. If logging is enabled, logs will be exported to
  // Stackdriver.
  optional BackendServiceLogConfig log_config = 24 [json_name = "logConfig"];

  // Specifies the default maximum duration (timeout) for streams to this
  // service. Duration is computed from the beginning of the stream until the
  // response has been completely processed, including all retries. A stream
  // that does not complete in this duration is closed. If not specified, there
  // will be no timeout limit, i.e. the maximum duration is infinite. This value
  // can be overridden in the PathMatcher configuration of the UrlMap that
  // references this backend service. This field is only allowed when the
  // loadBalancingScheme of the backend service is INTERNAL_SELF_MANAGED.
  optional Duration max_stream_duration = 25 [json_name = "maxStreamDuration"];

  // Deployment metadata associated with the resource to be set by a GKE hub
  // controller and read by the backend RCTH
  map<string, string> metadatas = 40 [json_name = "metadatas"];

  // Name of the resource. Provided by the client when the resource is created.
  // The name must be 1-63 characters long, and comply with RFC1035.
  // Specifically, the name must be 1-63 characters long and match the regular
  // expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  // must be a lowercase letter, and all following characters must be a dash,
  // lowercase letter, or digit, except the last character, which cannot be a
  // dash.
  optional string name = 26 [json_name = "name"];

  // The URL of the network to which this backend service belongs. This field
  // can only be specified when the load balancing scheme is set to INTERNAL.
  optional string network = 27 [json_name = "network"];

  // Settings controlling the ejection of unhealthy backend endpoints from the
  // load balancing pool of each individual proxy instance that processes the
  // traffic for the given backend service. If not set, this feature is
  // considered disabled. Results of the outlier detection algorithm (ejection
  // of endpoints from the load balancing pool and returning them back to the
  // pool) are executed independently by each proxy instance of the load
  // balancer. In most cases, more than one proxy instance handles the traffic
  // received by a backend service. Thus, it is possible that an unhealthy
  // endpoint is detected and ejected by only some of the proxies, and while
  // this happens, other proxies may continue to send requests to the same
  // unhealthy endpoint until they detect and eject the unhealthy endpoint.
  // Applicable backend endpoints can be: - VM instances in an Instance Group -
  // Endpoints in a Zonal NEG (GCE_VM_IP, GCE_VM_IP_PORT) - Endpoints in a
  // Hybrid Connectivity NEG (NON_GCP_PRIVATE_IP_PORT) - Serverless NEGs, that
  // resolve to Cloud Run, App Engine, or Cloud Functions Services - Private
  // Service Connect NEGs, that resolve to Google-managed regional API endpoints
  // or managed services published using Private Service Connect Applicable
  // backend service types can be: - A global backend service with the
  // loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL_MANAGED. - A
  // regional backend service with the serviceProtocol set to HTTP, HTTPS, or
  // HTTP2, and loadBalancingScheme set to INTERNAL_MANAGED or EXTERNAL_MANAGED.
  // Not supported for Serverless NEGs. Not supported when the backend service
  // is referenced by a URL map that is bound to target gRPC proxy that has
  // validateForProxyless field set to true.
  optional OutlierDetection outlier_detection = 28
      [json_name = "outlierDetection"];

  // Deprecated in favor of portName. The TCP port to connect on the backend.
  // The default value is 80. For internal passthrough Network Load Balancers
  // and external passthrough Network Load Balancers, omit port.
  optional int32 port = 29 [json_name = "port"];

  // A named port on a backend instance group representing the port for
  // communication to the backend VMs in that group. The named port must be
  // [defined on each backend instance
  // group](https://cloud.google.com/load-balancing/docs/backend-service#named_ports).
  // This parameter has no meaning if the backends are NEGs. For internal
  // passthrough Network Load Balancers and external passthrough Network Load
  // Balancers, omit port_name.
  optional string port_name = 30 [json_name = "portName"];

  // The protocol this BackendService uses to communicate with backends.
  // Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on
  // the chosen load balancer or Traffic Director configuration. Refer to the
  // documentation for the load balancers or for Traffic Director for more
  // information. Must be set to GRPC when the backend service is referenced by
  // a URL map that is bound to target gRPC proxy.
  // GRPC: gRPC (available for Traffic Director).
  // HTTP:
  // HTTP2: HTTP/2 with SSL.
  // HTTPS:
  // SSL: TCP proxying with SSL.
  // TCP: TCP proxying or TCP pass-through.
  // UDP: UDP.
  // UNSPECIFIED: If a Backend Service has UNSPECIFIED as its protocol, it can
  // be used with any L3/L4 Forwarding Rules.
  optional string protocol = 31 [json_name = "protocol"];

  // [Output Only] URL of the region where the regional backend service resides.
  // This field is not applicable to global backend services. You must specify
  // this field as part of the HTTP request URL. It is not settable as a field
  // in the request body.
  optional string region = 32 [json_name = "region"];

  // [Output Only] The resource URL for the security policy associated with this
  // backend service.
  optional string security_policy = 33 [json_name = "securityPolicy"];

  // This field specifies the security settings that apply to this backend
  // service. This field is applicable to a global backend service with the
  // load_balancing_scheme set to INTERNAL_SELF_MANAGED.
  optional SecuritySettings security_settings = 34
      [json_name = "securitySettings"];

  // [Output Only] Server-defined URL for the resource.
  optional string self_link = 35 [json_name = "selfLink"];

  // URLs of networkservices.ServiceBinding resources. Can only be set if load
  // balancing scheme is INTERNAL_SELF_MANAGED. If set, lists of backends and
  // health checks must be both empty.
  repeated string service_bindings = 36 [json_name = "serviceBindings"];

  // URL to networkservices.ServiceLbPolicy resource. Can only be set if load
  // balancing scheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED or
  // INTERNAL_SELF_MANAGED and the scope is global.
  optional string service_lb_policy = 42 [json_name = "serviceLbPolicy"];

  // Type of session affinity to use. The default is NONE. Only NONE and
  // HEADER_FIELD are supported when the backend service is referenced by a URL
  // map that is bound to target gRPC proxy that has validateForProxyless field
  // set to true. For more details, see: [Session
  // Affinity](https://cloud.google.com/load-balancing/docs/backend-service#session_affinity).
  // CLIENT_IP: 2-tuple hash on packet's source and destination IP addresses.
  // Connections from the same source IP address to the same destination IP
  // address will be served by the same backend VM while that VM remains
  // healthy.
  // CLIENT_IP_NO_DESTINATION: 1-tuple hash only on packet's source IP address.
  // Connections from the same source IP address will be served by the same
  // backend VM while that VM remains healthy. This option can only be used for
  // Internal TCP/UDP Load Balancing.
  // CLIENT_IP_PORT_PROTO: 5-tuple hash on packet's source and destination IP
  // addresses, IP protocol, and source and destination ports. Connections for
  // the same IP protocol from the same source IP address and port to the same
  // destination IP address and port will be served by the same backend VM while
  // that VM remains healthy. This option cannot be used for HTTP(S) load
  // balancing.
  // CLIENT_IP_PROTO: 3-tuple hash on packet's source and destination IP
  // addresses, and IP protocol. Connections for the same IP protocol from the
  // same source IP address to the same destination IP address will be served by
  // the same backend VM while that VM remains healthy. This option cannot be
  // used for HTTP(S) load balancing.
  // GENERATED_COOKIE: Hash based on a cookie generated by the L7 loadbalancer.
  // Only valid for HTTP(S) load balancing.
  // HEADER_FIELD: The hash is based on a user specified header field.
  // HTTP_COOKIE: The hash is based on a user provided cookie.
  // NONE: No session affinity. Connections from the same client IP may go to
  // any instance in the pool.
  // STRONG_COOKIE_AFFINITY: Strong cookie-based affinity. Connections bearing
  // the same cookie will be served by the same backend VM while that VM remains
  // healthy, as long as the cookie has not expired.
  optional string session_affinity = 37 [json_name = "sessionAffinity"];

  // Describes the HTTP cookie used for stateful session affinity. This field is
  // applicable and required if the sessionAffinity is set to
  // STRONG_COOKIE_AFFINITY.
  optional BackendServiceHttpCookie strong_session_affinity_cookie = 44
      [json_name = "strongSessionAffinityCookie"];

  optional Subsetting subsetting = 38 [json_name = "subsetting"];

  // The backend service timeout has a different meaning depending on the type
  // of load balancer. For more information see, Backend service settings. The
  // default is 30 seconds. The full range of timeout values allowed goes from 1
  // through 2,147,483,647 seconds. This value can be overridden in the
  // PathMatcher configuration of the UrlMap that references this backend
  // service. Not supported when the backend service is referenced by a URL map
  // that is bound to target gRPC proxy that has validateForProxyless field set
  // to true. Instead, use maxStreamDuration.
  optional int32 timeout_sec = 39 [json_name = "timeoutSec"];

  // [Output Only] List of resources referencing given backend service.
  repeated BackendServiceUsedBy used_by = 41 [json_name = "usedBy"];
}

// Message containing Cloud CDN configuration for a backend service.
message BackendServiceCdnPolicy {
  // Bypass the cache when the specified request headers are matched - e.g.
  // Pragma or Authorization headers. Up to 5 headers can be specified. The
  // cache is bypassed for all cdnPolicy.cacheMode settings.
  repeated BackendServiceCdnPolicyBypassCacheOnRequestHeader
      bypass_cache_on_request_headers = 1
      [json_name = "bypassCacheOnRequestHeaders"];

  // The CacheKeyPolicy for this CdnPolicy.
  optional CacheKeyPolicy cache_key_policy = 2 [json_name = "cacheKeyPolicy"];

  // Specifies the cache setting for all responses from this backend. The
  // possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid
  // caching headers to cache content. Responses without these headers will not
  // be cached at Google's edge, and will require a full trip to the origin on
  // every request, potentially impacting performance and increasing load on the
  // origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private",
  // "no-store" or "no-cache" directives in Cache-Control response headers.
  // Warning: this may result in Cloud CDN caching private, per-user (user
  // identifiable) content. CACHE_ALL_STATIC Automatically cache static content,
  // including common image formats, media (video and audio), and web assets
  // (JavaScript and CSS). Requests and responses that are marked as
  // uncacheable, as well as dynamic content (including HTML), will not be
  // cached. If no value is provided for cdnPolicy.cacheMode, it defaults to
  // CACHE_ALL_STATIC.
  // CACHE_ALL_STATIC: Automatically cache static content, including common
  // image formats, media (video and audio), and web assets (JavaScript and
  // CSS). Requests and responses that are marked as uncacheable, as well as
  // dynamic content (including HTML), will not be cached.
  // FORCE_CACHE_ALL: Cache all content, ignoring any "private", "no-store" or
  // "no-cache" directives in Cache-Control response headers. Warning: this may
  // result in Cloud CDN caching private, per-user (user identifiable) content.
  // INVALID_CACHE_MODE:
  // USE_ORIGIN_HEADERS: Requires the origin to set valid caching headers to
  // cache content. Responses without these headers will not be cached at
  // Google's edge, and will require a full trip to the origin on every request,
  // potentially impacting performance and increasing load on the origin server.
  optional string cache_mode = 3 [json_name = "cacheMode"];

  // Specifies a separate client (e.g. browser client) maximum TTL. This is used
  // to clamp the max-age (or Expires) value sent to the client. With
  // FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for the
  // response max-age directive, along with a "public" directive. For cacheable
  // content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age from the
  // origin (if specified), or else sets the response max-age directive to the
  // lesser of the client_ttl and default_ttl, and also ensures a "public"
  // cache-control directive is present. If a client TTL is not specified, a
  // default value (1 hour) will be used. The maximum allowed value is
  // 31,622,400s (1 year).
  optional int32 client_ttl = 4 [json_name = "clientTtl"];

  // Specifies the default TTL for cached content served by this origin for
  // responses that do not have an existing valid TTL (max-age or s-max-age).
  // Setting a TTL of "0" means "always revalidate". The value of defaultTTL
  // cannot be set to a value greater than that of maxTTL, but can be equal.
  // When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will overwrite
  // the TTL set in all responses. The maximum allowed value is 31,622,400s (1
  // year), noting that infrequently accessed objects may be evicted from the
  // cache before the defined TTL.
  optional int32 default_ttl = 5 [json_name = "defaultTtl"];

  // Specifies the maximum allowed TTL for cached content served by this origin.
  // Cache directives that attempt to set a max-age or s-maxage higher than
  // this, or an Expires header more than maxTTL seconds in the future will be
  // capped at the value of maxTTL, as if it were the value of an s-maxage
  // Cache-Control directive. Headers sent to the client will not be modified.
  // Setting a TTL of "0" means "always revalidate". The maximum allowed value
  // is 31,622,400s (1 year), noting that infrequently accessed objects may be
  // evicted from the cache before the defined TTL.
  optional int32 max_ttl = 6 [json_name = "maxTtl"];

  // Negative caching allows per-status code TTLs to be set, in order to apply
  // fine-grained caching for common errors or redirects. This can reduce the
  // load on your origin and improve end-user experience by reducing response
  // latency. When the cache mode is set to CACHE_ALL_STATIC or
  // USE_ORIGIN_HEADERS, negative caching applies to responses with the
  // specified response code that lack any Cache-Control, Expires, or Pragma:
  // no-cache directives. When the cache mode is set to FORCE_CACHE_ALL,
  // negative caching applies to all responses with the specified response code,
  // and override any caching headers. By default, Cloud CDN will apply the
  // following default TTLs to these status codes: HTTP 300 (Multiple Choice),
  // 301, 308 (Permanent Redirects): 10m HTTP 404 (Not Found), 410 (Gone), 451
  // (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not Found), 421
  // (Misdirected Request), 501 (Not Implemented): 60s. These defaults can be
  // overridden in negative_caching_policy.
  optional bool negative_caching = 7 [json_name = "negativeCaching"];

  // Sets a cache TTL for the specified HTTP status code. negative_caching must
  // be enabled to configure negative_caching_policy. Omitting the policy and
  // leaving negative_caching enabled will use Cloud CDN's default cache TTLs.
  // Note that when specifying an explicit negative_caching_policy, you should
  // take care to specify a cache TTL for all response codes that you wish to
  // cache. Cloud CDN will not apply any default negative caching when a policy
  // exists.
  repeated BackendServiceCdnPolicyNegativeCachingPolicy
      negative_caching_policy = 8 [json_name = "negativeCachingPolicy"];

  // If true then Cloud CDN will combine multiple concurrent cache fill requests
  // into a small number of requests to the origin.
  optional bool request_coalescing = 9 [json_name = "requestCoalescing"];

  // Serve existing content from the cache (if available) when revalidating
  // content with the origin, or when an error is encountered when refreshing
  // the cache. This setting defines the default "max-stale" duration for any
  // cached responses that do not specify a max-stale directive. Stale responses
  // that exceed the TTL configured here will not be served. The default limit
  // (max-stale) is 86400s (1 day), which will allow stale content to be served
  // up to this limit beyond the max-age (or s-max-age) of a cached response.
  // The maximum allowed value is 604800 (1 week). Set this to zero (0) to
  // disable serve-while-stale.
  optional int32 serve_while_stale = 10 [json_name = "serveWhileStale"];

  // Maximum number of seconds the response to a signed URL request will be
  // considered fresh. After this time period, the response will be revalidated
  // before being served. Defaults to 1hr (3600s). When serving responses to
  // signed URL requests, Cloud CDN will internally behave as though all
  // responses from this backend had a "Cache-Control: public, max-age=[TTL]"
  // header, regardless of any existing Cache-Control header. The actual headers
  // served in responses will not be altered.
  optional string signed_url_cache_max_age_sec = 11
      [json_name = "signedUrlCacheMaxAgeSec"];

  // [Output Only] Names of the keys for signing request URLs.
  repeated string signed_url_key_names = 12 [json_name = "signedUrlKeyNames"];
}

// Bypass the cache when the specified request headers are present, e.g. Pragma
// or Authorization headers. Values are case insensitive. The presence of such a
// header overrides the cache_mode setting.
message BackendServiceCdnPolicyBypassCacheOnRequestHeader {
  // The header field name to match on when bypassing cache. Values are
  // case-insensitive.
  optional string header_name = 1 [json_name = "headerName"];
}

// Specify CDN TTLs for response error codes.
message BackendServiceCdnPolicyNegativeCachingPolicy {
  // The HTTP status code to define a TTL against. Only HTTP status codes 300,
  // 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be specified as
  // values, and you cannot specify a status code more than once.
  optional int32 code = 1 [json_name = "code"];

  // The TTL (in seconds) for which to cache responses with the corresponding
  // status code. The maximum allowed value is 1800s (30 minutes), noting that
  // infrequently accessed objects may be evicted from the cache before the
  // defined TTL.
  optional int32 ttl = 2 [json_name = "ttl"];
}

// Connection Tracking configuration for this BackendService.
message BackendServiceConnectionTrackingPolicy {
  // Specifies connection persistence when backends are unhealthy. The default
  // value is DEFAULT_FOR_PROTOCOL. If set to DEFAULT_FOR_PROTOCOL, the existing
  // connections persist on unhealthy backends only for connection-oriented
  // protocols (TCP and SCTP) and only if the Tracking Mode is PER_CONNECTION
  // (default tracking mode) or the Session Affinity is configured for 5-tuple.
  // They do not persist for UDP. If set to NEVER_PERSIST, after a backend
  // becomes unhealthy, the existing connections on the unhealthy backend are
  // never persisted on the unhealthy backend. They are always diverted to newly
  // selected healthy backends (unless all backends are unhealthy). If set to
  // ALWAYS_PERSIST, existing connections always persist on unhealthy backends
  // regardless of protocol and session affinity. It is generally not
  // recommended to use this mode overriding the default. For more details, see
  // [Connection Persistence for Network Load
  // Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#connection-persistence)
  // and [Connection Persistence for Internal TCP/UDP Load
  // Balancing](https://cloud.google.com/load-balancing/docs/internal#connection-persistence).
  // ALWAYS_PERSIST:
  // DEFAULT_FOR_PROTOCOL:
  // NEVER_PERSIST:
  optional string connection_persistence_on_unhealthy_backends = 1
      [json_name = "connectionPersistenceOnUnhealthyBackends"];

  // Enable Strong Session Affinity for external passthrough Network Load
  // Balancers. This option is not available publicly.
  optional bool enable_strong_affinity = 2 [json_name = "enableStrongAffinity"];

  // Specifies how long to keep a Connection Tracking entry while there is no
  // matching traffic (in seconds). For internal passthrough Network Load
  // Balancers: - The minimum (default) is 10 minutes and the maximum is 16
  // hours. - It can be set only if Connection Tracking is less than 5-tuple
  // (i.e. Session Affinity is CLIENT_IP_NO_DESTINATION, CLIENT_IP or
  // CLIENT_IP_PROTO, and Tracking Mode is PER_SESSION). For external
  // passthrough Network Load Balancers the default is 60 seconds. This option
  // is not available publicly.
  optional int32 idle_timeout_sec = 3 [json_name = "idleTimeoutSec"];

  // Specifies the key used for connection tracking. There are two options: -
  // PER_CONNECTION: This is the default mode. The Connection Tracking is
  // performed as per the Connection Key (default Hash Method) for the specific
  // protocol. - PER_SESSION: The Connection Tracking is performed as per the
  // configured Session Affinity. It matches the configured Session Affinity.
  // For more details, see [Tracking Mode for Network Load
  // Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#tracking-mode)
  // and [Tracking Mode for Internal TCP/UDP Load
  // Balancing](https://cloud.google.com/load-balancing/docs/internal#tracking-mode).
  // INVALID_TRACKING_MODE:
  // PER_CONNECTION:
  // PER_SESSION:
  optional string tracking_mode = 4 [json_name = "trackingMode"];
}

// Custom Metrics are used for WEIGHTED_ROUND_ROBIN locality_lb_policy.
message BackendServiceCustomMetric {
  // If true, the metric data is not used for load balancing.
  optional bool dry_run = 1 [json_name = "dryRun"];

  // Name of a custom utilization signal. The name must be 1-64 characters long
  // and match the regular expression [a-z]([-_.a-z0-9]*[a-z0-9])? which means
  // the first character must be a lowercase letter, and all following
  // characters must be a dash, period, underscore, lowercase letter, or digit,
  // except the last character, which cannot be a dash, period, or underscore.
  // For usage guidelines, see Custom Metrics balancing mode. This field can
  // only be used for a global or regional backend service with the
  // loadBalancingScheme set to EXTERNAL_MANAGED, INTERNAL_MANAGED
  // INTERNAL_SELF_MANAGED.
  optional string name = 2 [json_name = "name"];
}

// For load balancers that have configurable failover: [Internal passthrough
// Network Load
// Balancers](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
// and [external passthrough Network Load
// Balancers](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
// On failover or failback, this field indicates whether connection draining
// will be honored. Google Cloud has a fixed connection draining timeout of 10
// minutes. A setting of true terminates existing TCP connections to the active
// pool during failover and failback, immediately draining traffic. A setting of
// false allows existing TCP connections to persist, even on VMs no longer in
// the active pool, for up to the duration of the connection draining timeout
// (10 minutes).
message BackendServiceFailoverPolicy {
  // This can be set to true only if the protocol is TCP. The default is false.
  optional bool disable_connection_drain_on_failover = 1
      [json_name = "disableConnectionDrainOnFailover"];

  // If set to true, connections to the load balancer are dropped when all
  // primary and all backup backend VMs are unhealthy.If set to false,
  // connections are distributed among all primary VMs when all primary and all
  // backup backend VMs are unhealthy. For load balancers that have configurable
  // failover: [Internal passthrough Network Load
  // Balancers](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  // and [external passthrough Network Load
  // Balancers](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
  // The default is false.
  optional bool drop_traffic_if_unhealthy = 2
      [json_name = "dropTrafficIfUnhealthy"];

  // The value of the field must be in the range [0, 1]. If the value is 0, the
  // load balancer performs a failover when the number of healthy primary VMs
  // equals zero. For all other values, the load balancer performs a failover
  // when the total number of healthy primary VMs is less than this ratio. For
  // load balancers that have configurable failover: [Internal TCP/UDP Load
  // Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  // and [external TCP/UDP Load
  // Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
  optional float failover_ratio = 3 [json_name = "failoverRatio"];
}

message BackendServiceGroupHealth {
  // Metadata defined as annotations on the network endpoint group.
  map<string, string> annotations = 1 [json_name = "annotations"];

  // Health state of the backend instances or endpoints in requested instance or
  // network endpoint group, determined based on configured health checks.
  repeated HealthStatus health_status = 2 [json_name = "healthStatus"];

  // [Output Only] Type of resource. Always compute#backendServiceGroupHealth
  // for the health of backend services.
  optional string kind = 3 [json_name = "kind"];
}

// The HTTP cookie used for stateful session affinity.
message BackendServiceHttpCookie {
  // Name of the cookie.
  optional string name = 1 [json_name = "name"];

  // Path to set for the cookie.
  optional string path = 2 [json_name = "path"];

  // Lifetime of the cookie.
  optional Duration ttl = 3 [json_name = "ttl"];
}

// Identity-Aware Proxy
message BackendServiceIAP {
  // Whether the serving infrastructure will authenticate and authorize all
  // incoming requests.
  optional bool enabled = 1 [json_name = "enabled"];

  // OAuth2 client ID to use for the authentication flow.
  optional string oauth2_client_id = 2 [json_name = "oauth2ClientId"];

  // OAuth2 client secret to use for the authentication flow. For security
  // reasons, this value cannot be retrieved via the API. Instead, the SHA-256
  // hash of the value is returned in the oauth2ClientSecretSha256 field.
  // @InputOnly
  optional string oauth2_client_secret = 3 [json_name = "oauth2ClientSecret"];

  // [Output Only] SHA256 hash value for the field oauth2_client_secret above.
  optional string oauth2_client_secret_sha256 = 4
      [json_name = "oauth2ClientSecretSha256"];
}

// Contains a list of BackendService resources.
message BackendServiceList {
  // [Output Only] Unique identifier for the resource; defined by the server.
  optional string id = 1 [json_name = "id"];

  // A list of BackendService resources.
  repeated BackendService items = 2 [json_name = "items"];

  // [Output Only] Type of resource. Always compute#backendServiceList for lists
  // of backend services.
  optional string kind = 3 [json_name = "kind"];

  // [Output Only] This token allows you to get the next page of results for
  // list requests. If the number of results is larger than maxResults, use the
  // nextPageToken as a value for the query parameter pageToken in the next list
  // request. Subsequent list requests will have their own nextPageToken to
  // continue paging through the results.
  optional string next_page_token = 4 [json_name = "nextPageToken"];

  // [Output Only] Server-defined URL for this resource.
  optional string self_link = 5 [json_name = "selfLink"];

  message Warning {
    // [Output Only] A warning code, if applicable. For example, Compute Engine
    // returns NO_RESULTS_ON_PAGE if there are no results in the response.
    // CLEANUP_FAILED: Warning about failed cleanup of transient changes made by
    // a failed operation.
    // DEPRECATED_RESOURCE_USED: A link to a deprecated resource was created.
    // DEPRECATED_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as deprecated
    // DISK_SIZE_LARGER_THAN_IMAGE_SIZE: The user created a boot disk that is
    // larger than image size.
    // EXPERIMENTAL_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as experimental
    // EXTERNAL_API_WARNING: Warning that is present in an external api call
    // FIELD_VALUE_OVERRIDEN: Warning that value of a field has been overridden.
    // Deprecated unused field.
    // INJECTED_KERNELS_DEPRECATED: The operation involved use of an injected
    // kernel, which is deprecated.
    // INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB: A WEIGHTED_MAGLEV backend
    // service is associated with a health check that is not of type
    // HTTP/HTTPS/HTTP2.
    // LARGE_DEPLOYMENT_WARNING: When deploying a deployment with a exceedingly
    // large number of resources
    // LIST_OVERHEAD_QUOTA_EXCEED: Resource can't be retrieved due to list
    // overhead quota exceed which captures the amount of resources filtered out
    // by user-defined list filter.
    // MISSING_TYPE_DEPENDENCY: A resource depends on a missing type
    // NEXT_HOP_ADDRESS_NOT_ASSIGNED: The route's nextHopIp address is not
    // assigned to an instance on the network.
    // NEXT_HOP_CANNOT_IP_FORWARD: The route's next hop instance cannot ip
    // forward.
    // NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE: The route's nextHopInstance URL
    // refers to an instance that does not have an ipv6 interface on the same
    // network as the route.
    // NEXT_HOP_INSTANCE_NOT_FOUND: The route's nextHopInstance URL refers to an
    // instance that does not exist.
    // NEXT_HOP_INSTANCE_NOT_ON_NETWORK: The route's nextHopInstance URL refers
    // to an instance that is not on the same network as the route.
    // NEXT_HOP_NOT_RUNNING: The route's next hop instance does not have a
    // status of RUNNING.
    // NOT_CRITICAL_ERROR: Error which is not critical. We decided to continue
    // the process despite the mentioned error.
    // NO_RESULTS_ON_PAGE: No results are present on a particular list page.
    // PARTIAL_SUCCESS: Success is reported, but some results may be missing due
    // to errors
    // QUOTA_INFO_UNAVAILABLE: Quota information is not available to client
    // requests (e.g: regions.list).
    // REQUIRED_TOS_AGREEMENT: The user attempted to use a resource that
    // requires a TOS they have not accepted.
    // RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING: Warning that a resource is in
    // use.
    // RESOURCE_NOT_DELETED: One or more of the resources set to auto-delete
    // could not be deleted because they were in use.
    // SCHEMA_VALIDATION_IGNORED: When a resource schema validation is ignored.
    // SINGLE_INSTANCE_PROPERTY_TEMPLATE: Instance template used in instance
    // group manager is valid as such, but its application does not make a lot
    // of sense, because it allows only single instance in instance group.
    // UNDECLARED_PROPERTIES: When undeclared properties in the schema are
    // present
    // UNREACHABLE: A given scope cannot be reached.
    optional string code = 1 [json_name = "code"];

    message DataItem {
      // [Output Only] A key that provides more detail on the warning being
      // returned. For example, for warnings where there are no results in a
      // list request for a particular zone, this key might be scope and the key
      // value might be the zone name. Other examples might be a key indicating
      // a deprecated resource and a suggested replacement, or a warning about
      // invalid network settings (for example, if an instance attempts to
      // perform IP forwarding but is not enabled for IP forwarding).
      optional string key = 1 [json_name = "key"];

      // [Output Only] A warning data value corresponding to the key.
      optional string value = 2 [json_name = "value"];
    }

    // [Output Only] Metadata about this warning in key: value format. For
    // example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    repeated DataItem data = 2 [json_name = "data"];

    // [Output Only] A human-readable description of the warning code.
    optional string message = 3 [json_name = "message"];
  }

  // [Output Only] Informational warning message.
  optional Warning warning = 6 [json_name = "warning"];
}

// Contains a list of usable BackendService resources.
message BackendServiceListUsable {
  // [Output Only] Unique identifier for the resource; defined by the server.
  optional string id = 1 [json_name = "id"];

  // A list of BackendService resources.
  repeated BackendService items = 2 [json_name = "items"];

  // [Output Only] Type of resource. Always compute#usableBackendServiceList for
  // lists of usable backend services.
  optional string kind = 3 [json_name = "kind"];

  // [Output Only] This token allows you to get the next page of results for
  // list requests. If the number of results is larger than maxResults, use the
  // nextPageToken as a value for the query parameter pageToken in the next list
  // request. Subsequent list requests will have their own nextPageToken to
  // continue paging through the results.
  optional string next_page_token = 4 [json_name = "nextPageToken"];

  // [Output Only] Server-defined URL for this resource.
  optional string self_link = 5 [json_name = "selfLink"];

  message Warning {
    // [Output Only] A warning code, if applicable. For example, Compute Engine
    // returns NO_RESULTS_ON_PAGE if there are no results in the response.
    // CLEANUP_FAILED: Warning about failed cleanup of transient changes made by
    // a failed operation.
    // DEPRECATED_RESOURCE_USED: A link to a deprecated resource was created.
    // DEPRECATED_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as deprecated
    // DISK_SIZE_LARGER_THAN_IMAGE_SIZE: The user created a boot disk that is
    // larger than image size.
    // EXPERIMENTAL_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as experimental
    // EXTERNAL_API_WARNING: Warning that is present in an external api call
    // FIELD_VALUE_OVERRIDEN: Warning that value of a field has been overridden.
    // Deprecated unused field.
    // INJECTED_KERNELS_DEPRECATED: The operation involved use of an injected
    // kernel, which is deprecated.
    // INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB: A WEIGHTED_MAGLEV backend
    // service is associated with a health check that is not of type
    // HTTP/HTTPS/HTTP2.
    // LARGE_DEPLOYMENT_WARNING: When deploying a deployment with a exceedingly
    // large number of resources
    // LIST_OVERHEAD_QUOTA_EXCEED: Resource can't be retrieved due to list
    // overhead quota exceed which captures the amount of resources filtered out
    // by user-defined list filter.
    // MISSING_TYPE_DEPENDENCY: A resource depends on a missing type
    // NEXT_HOP_ADDRESS_NOT_ASSIGNED: The route's nextHopIp address is not
    // assigned to an instance on the network.
    // NEXT_HOP_CANNOT_IP_FORWARD: The route's next hop instance cannot ip
    // forward.
    // NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE: The route's nextHopInstance URL
    // refers to an instance that does not have an ipv6 interface on the same
    // network as the route.
    // NEXT_HOP_INSTANCE_NOT_FOUND: The route's nextHopInstance URL refers to an
    // instance that does not exist.
    // NEXT_HOP_INSTANCE_NOT_ON_NETWORK: The route's nextHopInstance URL refers
    // to an instance that is not on the same network as the route.
    // NEXT_HOP_NOT_RUNNING: The route's next hop instance does not have a
    // status of RUNNING.
    // NOT_CRITICAL_ERROR: Error which is not critical. We decided to continue
    // the process despite the mentioned error.
    // NO_RESULTS_ON_PAGE: No results are present on a particular list page.
    // PARTIAL_SUCCESS: Success is reported, but some results may be missing due
    // to errors
    // QUOTA_INFO_UNAVAILABLE: Quota information is not available to client
    // requests (e.g: regions.list).
    // REQUIRED_TOS_AGREEMENT: The user attempted to use a resource that
    // requires a TOS they have not accepted.
    // RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING: Warning that a resource is in
    // use.
    // RESOURCE_NOT_DELETED: One or more of the resources set to auto-delete
    // could not be deleted because they were in use.
    // SCHEMA_VALIDATION_IGNORED: When a resource schema validation is ignored.
    // SINGLE_INSTANCE_PROPERTY_TEMPLATE: Instance template used in instance
    // group manager is valid as such, but its application does not make a lot
    // of sense, because it allows only single instance in instance group.
    // UNDECLARED_PROPERTIES: When undeclared properties in the schema are
    // present
    // UNREACHABLE: A given scope cannot be reached.
    optional string code = 1 [json_name = "code"];

    message DataItem {
      // [Output Only] A key that provides more detail on the warning being
      // returned. For example, for warnings where there are no results in a
      // list request for a particular zone, this key might be scope and the key
      // value might be the zone name. Other examples might be a key indicating
      // a deprecated resource and a suggested replacement, or a warning about
      // invalid network settings (for example, if an instance attempts to
      // perform IP forwarding but is not enabled for IP forwarding).
      optional string key = 1 [json_name = "key"];

      // [Output Only] A warning data value corresponding to the key.
      optional string value = 2 [json_name = "value"];
    }

    // [Output Only] Metadata about this warning in key: value format. For
    // example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    repeated DataItem data = 2 [json_name = "data"];

    // [Output Only] A human-readable description of the warning code.
    optional string message = 3 [json_name = "message"];
  }

  // [Output Only] Informational warning message.
  optional Warning warning = 6 [json_name = "warning"];
}

// Container for either a built-in LB policy supported by gRPC or Envoy or a
// custom one implemented by the end user.
message BackendServiceLocalityLoadBalancingPolicyConfig {
  optional BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy
      custom_policy = 1 [json_name = "customPolicy"];

  optional BackendServiceLocalityLoadBalancingPolicyConfigPolicy policy = 2
      [json_name = "policy"];
}

// The configuration for a custom policy implemented by the user and deployed
// with the client.
message BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy {
  // An optional, arbitrary JSON object with configuration data, understood by a
  // locally installed custom policy implementation.
  optional string data = 1 [json_name = "data"];

  // Identifies the custom policy. The value should match the name of a custom
  // implementation registered on the gRPC clients. It should follow protocol
  // buffer message naming conventions and include the full path (for example,
  // myorg.CustomLbPolicy). The maximum length is 256 characters. Do not specify
  // the same custom policy more than once for a backend. If you do, the
  // configuration is rejected. For an example of how to use this field, see Use
  // a custom policy.
  optional string name = 2 [json_name = "name"];
}

// The configuration for a built-in load balancing policy.
message BackendServiceLocalityLoadBalancingPolicyConfigPolicy {
  // The name of a locality load-balancing policy. Valid values include
  // ROUND_ROBIN and, for Java clients, LEAST_REQUEST. For information about
  // these values, see the description of localityLbPolicy. Do not specify the
  // same policy more than once for a backend. If you do, the configuration is
  // rejected.
  // INVALID_LB_POLICY:
  // LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and
  // picks the host which has fewer active requests.
  // MAGLEV: This algorithm implements consistent hashing to backends. Maglev
  // can be used as a drop in replacement for the ring hash load balancer.
  // Maglev is not as stable as ring hash but has faster table lookup build
  // times and host selection times. For more information about Maglev, see
  // https://ai.google/research/pubs/pub44824
  // ORIGINAL_DESTINATION: Backend host is selected based on the client
  // connection metadata, i.e., connections are opened to the same address as
  // the destination address of the incoming connection before the connection
  // was redirected to the load balancer.
  // RANDOM: The load balancer selects a random healthy host.
  // RING_HASH: The ring/modulo hash load balancer implements consistent hashing
  // to backends. The algorithm has the property that the addition/removal of a
  // host from a set of N hosts only affects 1/N of the requests.
  // ROUND_ROBIN: This is a simple policy in which each healthy backend is
  // selected in round robin order. This is the default.
  // WEIGHTED_MAGLEV: Per-instance weighted Load Balancing via health check
  // reported weights. If set, the Backend Service must configure a non legacy
  // HTTP-based Health Check, and health check replies are expected to contain
  // non-standard HTTP response header field X-Load-Balancing-Endpoint-Weight to
  // specify the per-instance weights. If set, Load Balancing is weighted based
  // on the per-instance weights reported in the last processed health check
  // replies, as long as every instance either reported a valid weight or had
  // UNAVAILABLE_WEIGHT. Otherwise, Load Balancing remains equal-weight. This
  // option is only supported in Network Load Balancing.
  // WEIGHTED_ROUND_ROBIN: Per-endpoint weighted round-robin Load Balancing
  // using weights computed from Backend reported Custom Metrics. If set, the
  // Backend Service responses are expected to contain non-standard HTTP
  // response header field X-Endpoint-Load-Metrics. The reported metrics to use
  // for computing the weights are specified via the backends[].customMetrics
  // fields.
  optional string name = 1 [json_name = "name"];
}

// The available logging options for the load balancer traffic served by this
// backend service.
message BackendServiceLogConfig {
  // Denotes whether to enable logging for the load balancer traffic served by
  // this backend service. The default value is false.
  optional bool enable = 1 [json_name = "enable"];

  // This field can only be specified if logging is enabled for this backend
  // service and "logConfig.optionalMode" was set to CUSTOM. Contains a list of
  // optional fields you want to include in the logs. For example:
  // serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
  repeated string optional_fields = 2 [json_name = "optionalFields"];

  // This field can only be specified if logging is enabled for this backend
  // service. Configures whether all, none or a subset of optional fields should
  // be added to the reported logs. One of [INCLUDE_ALL_OPTIONAL,
  // EXCLUDE_ALL_OPTIONAL, CUSTOM]. Default is EXCLUDE_ALL_OPTIONAL.
  // CUSTOM: A subset of optional fields.
  // EXCLUDE_ALL_OPTIONAL: None optional fields.
  // INCLUDE_ALL_OPTIONAL: All optional fields.
  optional string optional_mode = 3 [json_name = "optionalMode"];

  // This field can only be specified if logging is enabled for this backend
  // service. The value of the field must be in [0, 1]. This configures the
  // sampling rate of requests to the load balancer where 1.0 means all logged
  // requests are reported and 0.0 means no logged requests are reported. The
  // default value is 1.0.
  optional float sample_rate = 4 [json_name = "sampleRate"];
}

message BackendServiceUsedBy {
  // [Output Only] Server-defined URL for resources referencing given
  // BackendService like UrlMaps, TargetTcpProxies, TargetSslProxies and
  // ForwardingRule.
  optional string reference = 1 [json_name = "reference"];
}

// Message containing what to include in the cache key for a request for Cloud
// CDN.
message CacheKeyPolicy {
  // If true, requests to different hosts will be cached separately.
  optional bool include_host = 1 [json_name = "includeHost"];

  // Allows HTTP request headers (by name) to be used in the cache key.
  repeated string include_http_headers = 2 [json_name = "includeHttpHeaders"];

  // Allows HTTP cookies (by name) to be used in the cache key. The name=value
  // pair will be used in the cache key Cloud CDN generates.
  repeated string include_named_cookies = 3 [json_name = "includeNamedCookies"];

  // If true, http and https requests will be cached separately.
  optional bool include_protocol = 4 [json_name = "includeProtocol"];

  // If true, include query string parameters in the cache key according to
  // query_string_whitelist and query_string_blacklist. If neither is set, the
  // entire query string will be included. If false, the query string will be
  // excluded from the cache key entirely.
  optional bool include_query_string = 5 [json_name = "includeQueryString"];

  // Names of query string parameters to exclude in cache keys. All other
  // parameters will be included. Either specify query_string_whitelist or
  // query_string_blacklist, not both. '&' and '=' will be percent encoded and
  // not treated as delimiters.
  repeated string query_string_blacklist = 6
      [json_name = "queryStringBlacklist"];

  // Names of query string parameters to include in cache keys. All other
  // parameters will be excluded. Either specify query_string_whitelist or
  // query_string_blacklist, not both. '&' and '=' will be percent encoded and
  // not treated as delimiters.
  repeated string query_string_whitelist = 7
      [json_name = "queryStringWhitelist"];
}

// Settings controlling the volume of requests, connections and retries to this
// backend service.
message CircuitBreakers {
  // The maximum number of connections to the backend service. If not specified,
  // there is no limit. Not supported when the backend service is referenced by
  // a URL map that is bound to target gRPC proxy that has validateForProxyless
  // field set to true.
  optional int32 max_connections = 1 [json_name = "maxConnections"];

  // The maximum number of pending requests allowed to the backend service. If
  // not specified, there is no limit. Not supported when the backend service is
  // referenced by a URL map that is bound to target gRPC proxy that has
  // validateForProxyless field set to true.
  optional int32 max_pending_requests = 2 [json_name = "maxPendingRequests"];

  // The maximum number of parallel requests that allowed to the backend
  // service. If not specified, there is no limit.
  optional int32 max_requests = 3 [json_name = "maxRequests"];

  // Maximum requests for a single connection to the backend service. This
  // parameter is respected by both the HTTP/1.1 and HTTP/2 implementations. If
  // not specified, there is no limit. Setting this parameter to 1 will
  // effectively disable keep alive. Not supported when the backend service is
  // referenced by a URL map that is bound to target gRPC proxy that has
  // validateForProxyless field set to true.
  optional int32 max_requests_per_connection = 4
      [json_name = "maxRequestsPerConnection"];

  // The maximum number of parallel retries allowed to the backend cluster. If
  // not specified, the default is 1. Not supported when the backend service is
  // referenced by a URL map that is bound to target gRPC proxy that has
  // validateForProxyless field set to true.
  optional int32 max_retries = 5 [json_name = "maxRetries"];
}

// Message containing connection draining configuration.
message ConnectionDraining {
  // Configures a duration timeout for existing requests on a removed backend
  // instance. For supported load balancers and protocols, as described in
  // Enabling connection draining.
  optional int32 draining_timeout_sec = 1 [json_name = "drainingTimeoutSec"];
}

// This message defines settings for a consistent hash style load balancer.
message ConsistentHashLoadBalancerSettings {
  // Hash is based on HTTP Cookie. This field describes a HTTP cookie that will
  // be used as the hash key for the consistent hash load balancer. If the
  // cookie is not present, it will be generated. This field is applicable if
  // the sessionAffinity is set to HTTP_COOKIE. Not supported when the backend
  // service is referenced by a URL map that is bound to target gRPC proxy that
  // has validateForProxyless field set to true.
  optional ConsistentHashLoadBalancerSettingsHttpCookie http_cookie = 1
      [json_name = "httpCookie"];

  // The hash based on the value of the specified header field. This field is
  // applicable if the sessionAffinity is set to HEADER_FIELD.
  optional string http_header_name = 2 [json_name = "httpHeaderName"];

  // The minimum number of virtual nodes to use for the hash ring. Defaults to
  // 1024. Larger ring sizes result in more granular load distributions. If the
  // number of hosts in the load balancing pool is larger than the ring size,
  // each host will be assigned a single virtual node.
  optional string minimum_ring_size = 3 [json_name = "minimumRingSize"];
}

// The information about the HTTP Cookie on which the hash function is based for
// load balancing policies that use a consistent hash.
message ConsistentHashLoadBalancerSettingsHttpCookie {
  // Name of the cookie.
  optional string name = 1 [json_name = "name"];

  // Path to set for the cookie.
  optional string path = 2 [json_name = "path"];

  // Lifetime of the cookie.
  optional Duration ttl = 3 [json_name = "ttl"];
}

// Settings controlling the eviction of unhealthy hosts from the load balancing
// pool for the backend service.
message OutlierDetection {
  // The base time that a backend endpoint is ejected for. Defaults to 30000ms
  // or 30s. After a backend endpoint is returned back to the load balancing
  // pool, it can be ejected again in another ejection analysis. Thus, the total
  // ejection time is equal to the base ejection time multiplied by the number
  // of times the backend endpoint has been ejected. Defaults to 30000ms or 30s.
  optional Duration base_ejection_time = 1 [json_name = "baseEjectionTime"];

  // Number of consecutive errors before a backend endpoint is ejected from the
  // load balancing pool. When the backend endpoint is accessed over HTTP, a 5xx
  // return code qualifies as an error. Defaults to 5.
  optional int32 consecutive_errors = 2 [json_name = "consecutiveErrors"];

  // The number of consecutive gateway failures (502, 503, 504 status or
  // connection errors that are mapped to one of those status codes) before a
  // consecutive gateway failure ejection occurs. Defaults to 3.
  optional int32 consecutive_gateway_failure = 3
      [json_name = "consecutiveGatewayFailure"];

  // The percentage chance that a backend endpoint will be ejected when an
  // outlier status is detected through consecutive 5xx. This setting can be
  // used to disable ejection or to ramp it up slowly. Defaults to 0.
  optional int32 enforcing_consecutive_errors = 4
      [json_name = "enforcingConsecutiveErrors"];

  // The percentage chance that a backend endpoint will be ejected when an
  // outlier status is detected through consecutive gateway failures. This
  // setting can be used to disable ejection or to ramp it up slowly. Defaults
  // to 100.
  optional int32 enforcing_consecutive_gateway_failure = 5
      [json_name = "enforcingConsecutiveGatewayFailure"];

  // The percentage chance that a backend endpoint will be ejected when an
  // outlier status is detected through success rate statistics. This setting
  // can be used to disable ejection or to ramp it up slowly. Defaults to 100.
  // Not supported when the backend service uses Serverless NEG.
  optional int32 enforcing_success_rate = 6
      [json_name = "enforcingSuccessRate"];

  // Time interval between ejection analysis sweeps. This can result in both new
  // ejections and backend endpoints being returned to service. The interval is
  // equal to the number of seconds as defined in
  // outlierDetection.interval.seconds plus the number of nanoseconds as defined
  // in outlierDetection.interval.nanos. Defaults to 1 second.
  optional Duration interval = 7 [json_name = "interval"];

  // Maximum percentage of backend endpoints in the load balancing pool for the
  // backend service that can be ejected if the ejection conditions are met.
  // Defaults to 50%.
  optional int32 max_ejection_percent = 8 [json_name = "maxEjectionPercent"];

  // The number of backend endpoints in the load balancing pool that must have
  // enough request volume to detect success rate outliers. If the number of
  // backend endpoints is fewer than this setting, outlier detection via success
  // rate statistics is not performed for any backend endpoint in the load
  // balancing pool. Defaults to 5. Not supported when the backend service uses
  // Serverless NEG.
  optional int32 success_rate_minimum_hosts = 9
      [json_name = "successRateMinimumHosts"];

  // The minimum number of total requests that must be collected in one interval
  // (as defined by the interval duration above) to include this backend
  // endpoint in success rate based outlier detection. If the volume is lower
  // than this setting, outlier detection via success rate statistics is not
  // performed for that backend endpoint. Defaults to 100. Not supported when
  // the backend service uses Serverless NEG.
  optional int32 success_rate_request_volume = 10
      [json_name = "successRateRequestVolume"];

  // This factor is used to determine the ejection threshold for success rate
  // outlier ejection. The ejection threshold is the difference between the mean
  // success rate, and the product of this factor and the standard deviation of
  // the mean success rate: mean - (stdev * successRateStdevFactor). This factor
  // is divided by a thousand to get a double. That is, if the desired factor is
  // 1.9, the runtime value should be 1900. Defaults to 1900. Not supported when
  // the backend service uses Serverless NEG.
  optional int32 success_rate_stdev_factor = 11
      [json_name = "successRateStdevFactor"];
}

message ResourceGroupReference {
  // A URI referencing one of the instance groups or network endpoint groups
  // listed in the backend service.
  optional string group = 1 [json_name = "group"];
}

// The authentication and authorization settings for a BackendService.
message SecuritySettings {
  // The configuration needed to generate a signature for access to private
  // storage buckets that support AWS's Signature Version 4 for authentication.
  // Allowed only for INTERNET_IP_PORT and INTERNET_FQDN_PORT NEG backends.
  optional AWSV4Signature aws_v4_authentication = 3
      [json_name = "awsV4Authentication"];

  // Optional. A URL referring to a networksecurity.ClientTlsPolicy resource
  // that describes how clients should authenticate with this service's
  // backends. clientTlsPolicy only applies to a global BackendService with the
  // loadBalancingScheme set to INTERNAL_SELF_MANAGED. If left blank,
  // communications are not encrypted.
  optional string client_tls_policy = 1 [json_name = "clientTlsPolicy"];

  // Optional. A list of Subject Alternative Names (SANs) that the client
  // verifies during a mutual TLS handshake with an server/endpoint for this
  // BackendService. When the server presents its X.509 certificate to the
  // client, the client inspects the certificate's subjectAltName field. If the
  // field contains one of the specified values, the communication continues.
  // Otherwise, it fails. This additional check enables the client to verify
  // that the server is authorized to run the requested service. Note that the
  // contents of the server certificate's subjectAltName field are configured by
  // the Public Key Infrastructure which provisions server identities. Only
  // applies to a global BackendService with loadBalancingScheme set to
  // INTERNAL_SELF_MANAGED. Only applies when BackendService has an attached
  // clientTlsPolicy with clientCertificate (mTLS mode).
  repeated string subject_alt_names = 2 [json_name = "subjectAltNames"];
}

// Subsetting configuration for this BackendService. Currently this is
// applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load
// balancing and Traffic Director.
message Subsetting {
  // CONSISTENT_HASH_SUBSETTING: Subsetting based on consistent hashing. For
  // Traffic Director, the number of backends per backend group (the subset
  // size) is based on the `subset_size` parameter. For Internal HTTP(S) load
  // balancing, the number of backends per backend group (the subset size) is
  // dynamically adjusted in two cases: - As the number of proxy instances
  // participating in Internal HTTP(S) load balancing increases, the subset size
  // decreases. - When the total number of backends in a network exceeds the
  // capacity of a single proxy instance, subset sizes are reduced automatically
  // for each service that has backend subsetting enabled.
  // NONE: No Subsetting. Clients may open connections and send traffic to all
  // backends of this backend service. This can lead to performance issues if
  // there is substantial imbalance in the count of clients and backends.
  optional string policy = 1 [json_name = "policy"];
}
