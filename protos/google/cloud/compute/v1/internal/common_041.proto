// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the C++ microgenerator.
// If you make any local changes, they will be lost.
// file:///workspace/generator/discovery/compute_public_google_rest_v1.json
// revision: 20241231

syntax = "proto3";

package google.cloud.cpp.compute.v1;

import "google/cloud/compute/v1/internal/common_078.proto";

// Represents a Forwarding Rule resource. Forwarding rule resources in Google
// Cloud can be either regional or global in scope: *
// [Global](https://cloud.google.com/compute/docs/reference/rest/v1/globalForwardingRules)
// *
// [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/forwardingRules)
// A forwarding rule and its corresponding IP address represent the frontend
// configuration of a Google Cloud load balancer. Forwarding rules can also
// reference target instances and Cloud VPN Classic gateways (targetVpnGateway).
// For more information, read Forwarding rule concepts and Using protocol
// forwarding.
message ForwardingRule {
  // IP address for which this forwarding rule accepts traffic. When a client
  // sends traffic to this IP address, the forwarding rule directs the traffic
  // to the referenced target or backendService. While creating a forwarding
  // rule, specifying an IPAddress is required under the following
  // circumstances: - When the target is set to targetGrpcProxy and
  // validateForProxyless is set to true, the IPAddress should be set to
  // 0.0.0.0. - When the target is a Private Service Connect Google APIs bundle,
  // you must specify an IPAddress. Otherwise, you can optionally specify an IP
  // address that references an existing static (reserved) IP address resource.
  // When omitted, Google Cloud assigns an ephemeral IP address. Use one of the
  // following formats to specify an IP address while creating a forwarding
  // rule: * IP address number, as in `100.1.2.3` * IPv6 address range, as in
  // `2600:1234::/96` * Full resource URL, as in
  // https://www.googleapis.com/compute/v1/projects/
  // project_id/regions/region/addresses/address-name * Partial URL or by name,
  // as in: - projects/project_id/regions/region/addresses/address-name -
  // regions/region/addresses/address-name - global/addresses/address-name -
  // address-name The forwarding rule's target or backendService, and in most
  // cases, also the loadBalancingScheme, determine the type of IP address that
  // you can use. For detailed information, see [IP address
  // specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
  // When reading an IPAddress, the API always returns the IP address number.
  optional string ip_address = 1 [json_name = "IPAddress"];

  // The IP protocol to which this rule applies. For protocol forwarding, valid
  // options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The valid IP
  // protocols are different for different load balancing products as described
  // in [Load balancing
  // features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).
  // AH:
  // ESP:
  // ICMP:
  // L3_DEFAULT:
  // SCTP:
  // TCP:
  // UDP:
  optional string ip_protocol = 2 [json_name = "IPProtocol"];

  // The ports, portRange, and allPorts fields are mutually exclusive. Only
  // packets addressed to ports in the specified range will be forwarded to the
  // backends configured with this forwarding rule. The allPorts field has the
  // following limitations: - It requires that the forwarding rule IPProtocol be
  // TCP, UDP, SCTP, or L3_DEFAULT. - It's applicable only to the following
  // products: internal passthrough Network Load Balancers, backend
  // service-based external passthrough Network Load Balancers, and internal and
  // external protocol forwarding. - Set this field to true to allow packets
  // addressed to any port or packets lacking destination port information (for
  // example, UDP fragments after the first fragment) to be forwarded to the
  // backends configured with this forwarding rule. The L3_DEFAULT protocol
  // requires allPorts be set to true.
  optional bool all_ports = 3 [json_name = "allPorts"];

  // If set to true, clients can access the internal passthrough Network Load
  // Balancers, the regional internal Application Load Balancer, and the
  // regional internal proxy Network Load Balancer from all regions. If false,
  // only allows access from the local region the load balancer is located at.
  // Note that for INTERNAL_MANAGED forwarding rules, this field cannot be
  // changed after the forwarding rule is created.
  optional bool allow_global_access = 4 [json_name = "allowGlobalAccess"];

  // This is used in PSC consumer ForwardingRule to control whether the PSC
  // endpoint can be accessed from another region.
  optional bool allow_psc_global_access = 34
      [json_name = "allowPscGlobalAccess"];

  // Identifies the backend service to which the forwarding rule sends traffic.
  // Required for internal and external passthrough Network Load Balancers; must
  // be omitted for all other load balancer types.
  optional string backend_service = 5 [json_name = "backendService"];

  // [Output Only] The URL for the corresponding base forwarding rule. By base
  // forwarding rule, we mean the forwarding rule that has the same IP address,
  // protocol, and port settings with the current forwarding rule, but without
  // sourceIPRanges specified. Always empty if the current forwarding rule does
  // not have sourceIPRanges specified.
  optional string base_forwarding_rule = 6 [json_name = "baseForwardingRule"];

  // [Output Only] Creation timestamp in RFC3339 text format.
  optional string creation_timestamp = 7 [json_name = "creationTimestamp"];

  // An optional description of this resource. Provide this property when you
  // create the resource.
  optional string description = 8 [json_name = "description"];

  // Fingerprint of this resource. A hash of the contents stored in this object.
  // This field is used in optimistic locking. This field will be ignored when
  // inserting a ForwardingRule. Include the fingerprint in patch request to
  // ensure that you do not overwrite changes that were applied from another
  // concurrent request. To see the latest fingerprint, make a get() request to
  // retrieve a ForwardingRule.
  optional string fingerprint = 9 [json_name = "fingerprint"];

  // [Output Only] The unique identifier for the resource. This identifier is
  // defined by the server.
  optional string id = 10 [json_name = "id"];

  // Resource reference of a PublicDelegatedPrefix. The PDP must be a sub-PDP in
  // EXTERNAL_IPV6_FORWARDING_RULE_CREATION mode. Use one of the following
  // formats to specify a sub-PDP when creating an IPv6 NetLB forwarding rule
  // using BYOIP: Full resource URL, as in
  // https://www.googleapis.com/compute/v1/projects/project_id/regions/region
  // /publicDelegatedPrefixes/sub-pdp-name Partial URL, as in: -
  // projects/project_id/regions/region/publicDelegatedPrefixes/sub-pdp-name -
  // regions/region/publicDelegatedPrefixes/sub-pdp-name
  optional string ip_collection = 35 [json_name = "ipCollection"];

  // The IP Version that will be used by this forwarding rule. Valid options are
  // IPV4 or IPV6.
  // IPV4:
  // IPV6:
  // UNSPECIFIED_VERSION:
  optional string ip_version = 11 [json_name = "ipVersion"];

  // Indicates whether or not this load balancer can be used as a collector for
  // packet mirroring. To prevent mirroring loops, instances behind this load
  // balancer will not have their traffic mirrored even if a PacketMirroring
  // rule applies to them. This can only be set to true for load balancers that
  // have their loadBalancingScheme set to INTERNAL.
  optional bool is_mirroring_collector = 12
      [json_name = "isMirroringCollector"];

  // [Output Only] Type of the resource. Always compute#forwardingRule for
  // forwarding rule resources.
  optional string kind = 13 [json_name = "kind"];

  // A fingerprint for the labels being applied to this resource, which is
  // essentially a hash of the labels set used for optimistic locking. The
  // fingerprint is initially generated by Compute Engine and changes after
  // every request to modify or update labels. You must always provide an
  // up-to-date fingerprint hash in order to update or change labels, otherwise
  // the request will fail with error 412 conditionNotMet. To see the latest
  // fingerprint, make a get() request to retrieve a ForwardingRule.
  optional string label_fingerprint = 14 [json_name = "labelFingerprint"];

  // Labels for this resource. These can only be added or modified by the
  // setLabels method. Each label key/value pair must comply with RFC1035. Label
  // values may be empty.
  map<string, string> labels = 15 [json_name = "labels"];

  // Specifies the forwarding rule type. For more information about forwarding
  // rules, refer to Forwarding rule concepts.
  // EXTERNAL:
  // EXTERNAL_MANAGED:
  // INTERNAL:
  // INTERNAL_MANAGED:
  // INTERNAL_SELF_MANAGED:
  // INVALID:
  optional string load_balancing_scheme = 16
      [json_name = "loadBalancingScheme"];

  // Opaque filter criteria used by load balancer to restrict routing
  // configuration to a limited set of xDS compliant clients. In their xDS
  // requests to load balancer, xDS clients present node metadata. When there is
  // a match, the relevant configuration is made available to those proxies.
  // Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by
  // the ForwardingRule are not visible to those proxies. For each
  // metadataFilter in this list, if its filterMatchCriteria is set to
  // MATCH_ANY, at least one of the filterLabels must match the corresponding
  // label provided in the metadata. If its filterMatchCriteria is set to
  // MATCH_ALL, then all of its filterLabels must match with corresponding
  // labels provided in the metadata. If multiple metadataFilters are specified,
  // all of them need to be satisfied in order to be considered a match.
  // metadataFilters specified here will be applifed before those specified in
  // the UrlMap that this ForwardingRule references. metadataFilters only
  // applies to Loadbalancers that have their loadBalancingScheme set to
  // INTERNAL_SELF_MANAGED.
  repeated MetadataFilter metadata_filters = 17 [json_name = "metadataFilters"];

  // Name of the resource; provided by the client when the resource is created.
  // The name must be 1-63 characters long, and comply with RFC1035.
  // Specifically, the name must be 1-63 characters long and match the regular
  // expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  // must be a lowercase letter, and all following characters must be a dash,
  // lowercase letter, or digit, except the last character, which cannot be a
  // dash. For Private Service Connect forwarding rules that forward traffic to
  // Google APIs, the forwarding rule name must be a 1-20 characters string with
  // lowercase letters and numbers and must start with a letter.
  optional string name = 18 [json_name = "name"];

  // This field is not used for global external load balancing. For internal
  // passthrough Network Load Balancers, this field identifies the network that
  // the load balanced IP should belong to for this forwarding rule. If the
  // subnetwork is specified, the network of the subnetwork will be used. If
  // neither subnetwork nor this field is specified, the default network will be
  // used. For Private Service Connect forwarding rules that forward traffic to
  // Google APIs, a network must be provided.
  optional string network = 19 [json_name = "network"];

  // This signifies the networking tier used for configuring this load balancer
  // and can only take the following values: PREMIUM, STANDARD. For regional
  // ForwardingRule, the valid values are PREMIUM and STANDARD. For
  // GlobalForwardingRule, the valid value is PREMIUM. If this field is not
  // specified, it is assumed to be PREMIUM. If IPAddress is specified, this
  // value must be equal to the networkTier of the Address.
  // FIXED_STANDARD: Public internet quality with fixed bandwidth.
  // PREMIUM: High quality, Google-grade network tier, support for all
  // networking products.
  // STANDARD: Public internet quality, only limited support for other
  // networking products.
  // STANDARD_OVERRIDES_FIXED_STANDARD: (Output only) Temporary tier for
  // FIXED_STANDARD when fixed standard tier is expired or not configured.
  optional string network_tier = 20 [json_name = "networkTier"];

  // This is used in PSC consumer ForwardingRule to control whether it should
  // try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use
  // this field. Once set, this field is not mutable.
  optional bool no_automate_dns_zone = 21 [json_name = "noAutomateDnsZone"];

  // The ports, portRange, and allPorts fields are mutually exclusive. Only
  // packets addressed to ports in the specified range will be forwarded to the
  // backends configured with this forwarding rule. The portRange field has the
  // following limitations: - It requires that the forwarding rule IPProtocol be
  // TCP, UDP, or SCTP, and - It's applicable only to the following products:
  // external passthrough Network Load Balancers, internal and external proxy
  // Network Load Balancers, internal and external Application Load Balancers,
  // external protocol forwarding, and Classic VPN. - Some products have
  // restrictions on what ports can be used. See port specifications for
  // details. For external forwarding rules, two or more forwarding rules cannot
  // use the same [IPAddress, IPProtocol] pair, and cannot have overlapping
  // portRanges. For internal forwarding rules within the same VPC network, two
  // or more forwarding rules cannot use the same [IPAddress, IPProtocol] pair,
  // and cannot have overlapping portRanges. @pattern: \\d+(?:-\\d+)?
  optional string port_range = 22 [json_name = "portRange"];

  // The ports, portRange, and allPorts fields are mutually exclusive. Only
  // packets addressed to ports in the specified range will be forwarded to the
  // backends configured with this forwarding rule. The ports field has the
  // following limitations: - It requires that the forwarding rule IPProtocol be
  // TCP, UDP, or SCTP, and - It's applicable only to the following products:
  // internal passthrough Network Load Balancers, backend service-based external
  // passthrough Network Load Balancers, and internal protocol forwarding. - You
  // can specify a list of up to five ports by number, separated by commas. The
  // ports can be contiguous or discontiguous. For external forwarding rules,
  // two or more forwarding rules cannot use the same [IPAddress, IPProtocol]
  // pair if they share at least one port number. For internal forwarding rules
  // within the same VPC network, two or more forwarding rules cannot use the
  // same [IPAddress, IPProtocol] pair if they share at least one port number.
  // @pattern: \\d+(?:-\\d+)?
  repeated string ports = 23 [json_name = "ports"];

  // [Output Only] The PSC connection id of the PSC forwarding rule.
  optional string psc_connection_id = 24 [json_name = "pscConnectionId"];

  // ACCEPTED: The connection has been accepted by the producer.
  // CLOSED: The connection has been closed by the producer and will not serve
  // traffic going forward.
  // NEEDS_ATTENTION: The connection has been accepted by the producer, but the
  // producer needs to take further action before the forwarding rule can serve
  // traffic.
  // PENDING: The connection is pending acceptance by the producer.
  // REJECTED: The connection has been rejected by the producer.
  // STATUS_UNSPECIFIED:
  optional string psc_connection_status = 25
      [json_name = "pscConnectionStatus"];

  // [Output Only] URL of the region where the regional forwarding rule resides.
  // This field is not applicable to global forwarding rules. You must specify
  // this field as part of the HTTP request URL. It is not settable as a field
  // in the request body.
  optional string region = 26 [json_name = "region"];

  // [Output Only] Server-defined URL for the resource.
  optional string self_link = 27 [json_name = "selfLink"];

  // Service Directory resources to register this forwarding rule with.
  // Currently, only supports a single Service Directory resource.
  repeated ForwardingRuleServiceDirectoryRegistration
      service_directory_registrations = 28
      [json_name = "serviceDirectoryRegistrations"];

  // An optional prefix to the service name for this forwarding rule. If
  // specified, the prefix is the first label of the fully qualified service
  // name. The label must be 1-63 characters long, and comply with RFC1035.
  // Specifically, the label must be 1-63 characters long and match the regular
  // expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  // must be a lowercase letter, and all following characters must be a dash,
  // lowercase letter, or digit, except the last character, which cannot be a
  // dash. This field is only used for internal load balancing.
  optional string service_label = 29 [json_name = "serviceLabel"];

  // [Output Only] The internal fully qualified service name for this forwarding
  // rule. This field is only used for internal load balancing.
  optional string service_name = 30 [json_name = "serviceName"];

  // If not empty, this forwarding rule will only forward the traffic when the
  // source IP address matches one of the IP addresses or CIDR ranges set here.
  // Note that a forwarding rule can only have up to 64 source IP ranges, and
  // this field can only be used with a regional forwarding rule whose scheme is
  // EXTERNAL. Each source_ip_range entry should be either an IP address (for
  // example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
  repeated string source_ip_ranges = 31 [json_name = "sourceIpRanges"];

  // This field identifies the subnetwork that the load balanced IP should
  // belong to for this forwarding rule, used with internal load balancers and
  // external passthrough Network Load Balancers with IPv6. If the network
  // specified is in auto subnet mode, this field is optional. However, a
  // subnetwork must be specified if the network is in custom subnet mode or
  // when creating external forwarding rule with IPv6.
  optional string subnetwork = 32 [json_name = "subnetwork"];

  // The URL of the target resource to receive the matched traffic. For regional
  // forwarding rules, this target must be in the same region as the forwarding
  // rule. For global forwarding rules, this target must be a global load
  // balancing resource. The forwarded traffic must be of a type appropriate to
  // the target object. - For load balancers, see the "Target" column in [Port
  // specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
  // - For Private Service Connect forwarding rules that forward traffic to
  // Google APIs, provide the name of a supported Google API bundle: - vpc-sc -
  // APIs that support VPC Service Controls. - all-apis - All supported Google
  // APIs. - For Private Service Connect forwarding rules that forward traffic
  // to managed services, the target must be a service attachment. The target is
  // not mutable once set as a service attachment.
  optional string target = 33 [json_name = "target"];
}

// Contains a list of ForwardingRule resources.
message ForwardingRuleList {
  // [Output Only] Unique identifier for the resource; defined by the server.
  optional string id = 1 [json_name = "id"];

  // A list of ForwardingRule resources.
  repeated ForwardingRule items = 2 [json_name = "items"];

  // Type of resource.
  optional string kind = 3 [json_name = "kind"];

  // [Output Only] This token allows you to get the next page of results for
  // list requests. If the number of results is larger than maxResults, use the
  // nextPageToken as a value for the query parameter pageToken in the next list
  // request. Subsequent list requests will have their own nextPageToken to
  // continue paging through the results.
  optional string next_page_token = 4 [json_name = "nextPageToken"];

  // [Output Only] Server-defined URL for this resource.
  optional string self_link = 5 [json_name = "selfLink"];

  message Warning {
    // [Output Only] A warning code, if applicable. For example, Compute Engine
    // returns NO_RESULTS_ON_PAGE if there are no results in the response.
    // CLEANUP_FAILED: Warning about failed cleanup of transient changes made by
    // a failed operation.
    // DEPRECATED_RESOURCE_USED: A link to a deprecated resource was created.
    // DEPRECATED_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as deprecated
    // DISK_SIZE_LARGER_THAN_IMAGE_SIZE: The user created a boot disk that is
    // larger than image size.
    // EXPERIMENTAL_TYPE_USED: When deploying and at least one of the resources
    // has a type marked as experimental
    // EXTERNAL_API_WARNING: Warning that is present in an external api call
    // FIELD_VALUE_OVERRIDEN: Warning that value of a field has been overridden.
    // Deprecated unused field.
    // INJECTED_KERNELS_DEPRECATED: The operation involved use of an injected
    // kernel, which is deprecated.
    // INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB: A WEIGHTED_MAGLEV backend
    // service is associated with a health check that is not of type
    // HTTP/HTTPS/HTTP2.
    // LARGE_DEPLOYMENT_WARNING: When deploying a deployment with a exceedingly
    // large number of resources
    // LIST_OVERHEAD_QUOTA_EXCEED: Resource can't be retrieved due to list
    // overhead quota exceed which captures the amount of resources filtered out
    // by user-defined list filter.
    // MISSING_TYPE_DEPENDENCY: A resource depends on a missing type
    // NEXT_HOP_ADDRESS_NOT_ASSIGNED: The route's nextHopIp address is not
    // assigned to an instance on the network.
    // NEXT_HOP_CANNOT_IP_FORWARD: The route's next hop instance cannot ip
    // forward.
    // NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE: The route's nextHopInstance URL
    // refers to an instance that does not have an ipv6 interface on the same
    // network as the route.
    // NEXT_HOP_INSTANCE_NOT_FOUND: The route's nextHopInstance URL refers to an
    // instance that does not exist.
    // NEXT_HOP_INSTANCE_NOT_ON_NETWORK: The route's nextHopInstance URL refers
    // to an instance that is not on the same network as the route.
    // NEXT_HOP_NOT_RUNNING: The route's next hop instance does not have a
    // status of RUNNING.
    // NOT_CRITICAL_ERROR: Error which is not critical. We decided to continue
    // the process despite the mentioned error.
    // NO_RESULTS_ON_PAGE: No results are present on a particular list page.
    // PARTIAL_SUCCESS: Success is reported, but some results may be missing due
    // to errors
    // QUOTA_INFO_UNAVAILABLE: Quota information is not available to client
    // requests (e.g: regions.list).
    // REQUIRED_TOS_AGREEMENT: The user attempted to use a resource that
    // requires a TOS they have not accepted.
    // RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING: Warning that a resource is in
    // use.
    // RESOURCE_NOT_DELETED: One or more of the resources set to auto-delete
    // could not be deleted because they were in use.
    // SCHEMA_VALIDATION_IGNORED: When a resource schema validation is ignored.
    // SINGLE_INSTANCE_PROPERTY_TEMPLATE: Instance template used in instance
    // group manager is valid as such, but its application does not make a lot
    // of sense, because it allows only single instance in instance group.
    // UNDECLARED_PROPERTIES: When undeclared properties in the schema are
    // present
    // UNREACHABLE: A given scope cannot be reached.
    optional string code = 1 [json_name = "code"];

    message DataItem {
      // [Output Only] A key that provides more detail on the warning being
      // returned. For example, for warnings where there are no results in a
      // list request for a particular zone, this key might be scope and the key
      // value might be the zone name. Other examples might be a key indicating
      // a deprecated resource and a suggested replacement, or a warning about
      // invalid network settings (for example, if an instance attempts to
      // perform IP forwarding but is not enabled for IP forwarding).
      optional string key = 1 [json_name = "key"];

      // [Output Only] A warning data value corresponding to the key.
      optional string value = 2 [json_name = "value"];
    }

    // [Output Only] Metadata about this warning in key: value format. For
    // example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    repeated DataItem data = 2 [json_name = "data"];

    // [Output Only] A human-readable description of the warning code.
    optional string message = 3 [json_name = "message"];
  }

  // [Output Only] Informational warning message.
  optional Warning warning = 6 [json_name = "warning"];
}

// Describes the auto-registration of the forwarding rule to Service Directory.
// The region and project of the Service Directory resource generated from this
// registration will be the same as this forwarding rule.
message ForwardingRuleServiceDirectoryRegistration {
  // Service Directory namespace to register the forwarding rule under.
  optional string namespace = 1 [json_name = "namespace"];

  // Service Directory service to register the forwarding rule under.
  optional string service = 2 [json_name = "service"];

  // [Optional] Service Directory region to register this global forwarding rule
  // under. Default to "us-central1". Only used for PSC for Google APIs. All PSC
  // for Google APIs forwarding rules on the same network should use the same
  // Service Directory region.
  optional string service_directory_region = 3
      [json_name = "serviceDirectoryRegion"];
}
