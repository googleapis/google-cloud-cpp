// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the C++ microgenerator.
// If you make any local changes, they will be lost.
// file:///workspace/generator/discovery/compute_public_google_rest_v1.json
// revision: 20240220

syntax = "proto3";

package google.cloud.cpp.compute.v1;

import "google/cloud/compute/v1/internal/common_016.proto";
import "google/cloud/compute/v1/internal/common_039.proto";
import "google/cloud/compute/v1/internal/common_076.proto";

message DistributionPolicy {
  // The distribution shape to which the group converges either proactively or
  // on resize events (depending on the value set in
  // updatePolicy.instanceRedistributionType).
  // ANY: The group picks zones for creating VM instances to fulfill the
  // requested number of VMs within present resource constraints and to maximize
  // utilization of unused zonal reservations. Recommended for batch workloads
  // that do not require high availability.
  // ANY_SINGLE_ZONE: The group creates all VM instances within a single zone.
  // The zone is selected based on the present resource constraints and to
  // maximize utilization of unused zonal reservations. Recommended for batch
  // workloads with heavy interprocess communication.
  // BALANCED: The group prioritizes acquisition of resources, scheduling VMs in
  // zones where resources are available while distributing VMs as evenly as
  // possible across selected zones to minimize the impact of zonal failure.
  // Recommended for highly available serving workloads.
  // EVEN: The group schedules VM instance creation and deletion to achieve and
  // maintain an even number of managed instances across the selected zones. The
  // distribution is even when the number of managed instances does not differ
  // by more than 1 between any two zones. Recommended for highly available
  // serving workloads.
  optional string target_shape = 1 [json_name = "targetShape"];

  // Zones where the regional managed instance group will create and manage its
  // instances.
  repeated DistributionPolicyZoneConfiguration zones = 2 [json_name = "zones"];
}

message DistributionPolicyZoneConfiguration {
  // The URL of the zone. The zone must exist in the region where the managed
  // instance group is located.
  optional string zone = 1 [json_name = "zone"];
}

// Represents a Managed Instance Group resource. An instance group is a
// collection of VM instances that you can manage as a single entity. For more
// information, read Instance groups. For zonal Managed Instance Group, use the
// instanceGroupManagers resource. For regional Managed Instance Group, use the
// regionInstanceGroupManagers resource.
message InstanceGroupManager {
  // Specifies configuration that overrides the instance template configuration
  // for the group.
  optional InstanceGroupManagerAllInstancesConfig all_instances_config = 25
      [json_name = "allInstancesConfig"];

  // The autohealing policy for this managed instance group. You can specify
  // only one value.
  repeated InstanceGroupManagerAutoHealingPolicy auto_healing_policies = 1
      [json_name = "autoHealingPolicies"];

  // The base instance name to use for instances in this group. The value must
  // be 1-58 characters long. Instances are named by appending a hyphen and a
  // random four-character string to the base instance name. The base instance
  // name must comply with RFC1035.
  optional string base_instance_name = 2 [json_name = "baseInstanceName"];

  // [Output Only] The creation timestamp for this managed instance group in
  // RFC3339 text format.
  optional string creation_timestamp = 3 [json_name = "creationTimestamp"];

  // [Output Only] The list of instance actions and the number of instances in
  // this managed instance group that are scheduled for each of those actions.
  optional InstanceGroupManagerActionsSummary current_actions = 4
      [json_name = "currentActions"];

  // An optional description of this resource.
  optional string description = 5 [json_name = "description"];

  // Policy specifying the intended distribution of managed instances across
  // zones in a regional managed instance group.
  optional DistributionPolicy distribution_policy = 6
      [json_name = "distributionPolicy"];

  // Fingerprint of this resource. This field may be used in optimistic locking.
  // It will be ignored when inserting an InstanceGroupManager. An up-to-date
  // fingerprint must be provided in order to update the InstanceGroupManager,
  // otherwise the request will fail with error 412 conditionNotMet. To see the
  // latest fingerprint, make a get() request to retrieve an
  // InstanceGroupManager.
  optional string fingerprint = 7 [json_name = "fingerprint"];

  // [Output Only] A unique identifier for this resource type. The server
  // generates this identifier.
  optional string id = 8 [json_name = "id"];

  // [Output Only] The URL of the Instance Group resource.
  optional string instance_group = 9 [json_name = "instanceGroup"];

  // The repair policy for this managed instance group.
  optional InstanceGroupManagerInstanceLifecyclePolicy
      instance_lifecycle_policy = 24 [json_name = "instanceLifecyclePolicy"];

  // The URL of the instance template that is specified for this managed
  // instance group. The group uses this template to create all new instances in
  // the managed instance group. The templates for existing instances in the
  // group do not change unless you run recreateInstances, run
  // applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
  optional string instance_template = 10 [json_name = "instanceTemplate"];

  // [Output Only] The resource type, which is always
  // compute#instanceGroupManager for managed instance groups.
  optional string kind = 11 [json_name = "kind"];

  // Pagination behavior of the listManagedInstances API method for this managed
  // instance group.
  // PAGELESS: (Default) Pagination is disabled for the group's
  // listManagedInstances API method. maxResults and pageToken query parameters
  // are ignored and all instances are returned in a single response.
  // PAGINATED: Pagination is enabled for the group's listManagedInstances API
  // method. maxResults and pageToken query parameters are respected.
  optional string list_managed_instances_results = 12
      [json_name = "listManagedInstancesResults"];

  // The name of the managed instance group. The name must be 1-63 characters
  // long, and comply with RFC1035.
  optional string name = 13 [json_name = "name"];

  // Named ports configured for the Instance Groups complementary to this
  // Instance Group Manager.
  repeated NamedPort named_ports = 14 [json_name = "namedPorts"];

  // [Output Only] The URL of the region where the managed instance group
  // resides (for regional resources).
  optional string region = 15 [json_name = "region"];

  // [Output Only] The URL for this managed instance group. The server defines
  // this URL.
  optional string self_link = 16 [json_name = "selfLink"];

  // Stateful configuration for this Instanced Group Manager
  optional StatefulPolicy stateful_policy = 17 [json_name = "statefulPolicy"];

  // [Output Only] The status of this managed instance group.
  optional InstanceGroupManagerStatus status = 18 [json_name = "status"];

  // The URLs for all TargetPool resources to which instances in the
  // instanceGroup field are added. The target pools automatically apply to all
  // of the instances in the managed instance group.
  repeated string target_pools = 19 [json_name = "targetPools"];

  // The target number of running instances for this managed instance group. You
  // can reduce this number by using the instanceGroupManager deleteInstances or
  // abandonInstances methods. Resizing the group also changes this number.
  optional int32 target_size = 20 [json_name = "targetSize"];

  // The update policy for this managed instance group.
  optional InstanceGroupManagerUpdatePolicy update_policy = 21
      [json_name = "updatePolicy"];

  // Specifies the instance templates used by this managed instance group to
  // create instances. Each version is defined by an instanceTemplate and a
  // name. Every version can appear at most once per instance group. This field
  // overrides the top-level instanceTemplate field. Read more about the
  // relationships between these fields. Exactly one version must leave the
  // targetSize field unset. That version will be applied to all remaining
  // instances. For more information, read about canary updates.
  repeated InstanceGroupManagerVersion versions = 22 [json_name = "versions"];

  // [Output Only] The URL of a zone where the managed instance group is located
  // (for zonal resources).
  optional string zone = 23 [json_name = "zone"];
}

message InstanceGroupManagerActionsSummary {
  // [Output Only] The total number of instances in the managed instance group
  // that are scheduled to be abandoned. Abandoning an instance removes it from
  // the managed instance group without deleting it.
  optional int32 abandoning = 1 [json_name = "abandoning"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be created or are currently being created. If the group
  // fails to create any of these instances, it tries again until it creates the
  // instance successfully. If you have disabled creation retries, this field
  // will not be populated; instead, the creatingWithoutRetries field will be
  // populated.
  optional int32 creating = 2 [json_name = "creating"];

  // [Output Only] The number of instances that the managed instance group will
  // attempt to create. The group attempts to create each instance only once. If
  // the group fails to create any of these instances, it decreases the group's
  // targetSize value accordingly.
  optional int32 creating_without_retries = 3
      [json_name = "creatingWithoutRetries"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be deleted or are currently being deleted.
  optional int32 deleting = 4 [json_name = "deleting"];

  // [Output Only] The number of instances in the managed instance group that
  // are running and have no scheduled actions.
  optional int32 none = 5 [json_name = "none"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be recreated or are currently being being recreated.
  // Recreating an instance deletes the existing root persistent disk and
  // creates a new disk from the image that is defined in the instance template.
  optional int32 recreating = 6 [json_name = "recreating"];

  // [Output Only] The number of instances in the managed instance group that
  // are being reconfigured with properties that do not require a restart or a
  // recreate action. For example, setting or removing target pools for the
  // instance.
  optional int32 refreshing = 7 [json_name = "refreshing"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be restarted or are currently being restarted.
  optional int32 restarting = 8 [json_name = "restarting"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be resumed or are currently being resumed.
  optional int32 resuming = 9 [json_name = "resuming"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be started or are currently being started.
  optional int32 starting = 10 [json_name = "starting"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be stopped or are currently being stopped.
  optional int32 stopping = 11 [json_name = "stopping"];

  // [Output Only] The number of instances in the managed instance group that
  // are scheduled to be suspended or are currently being suspended.
  optional int32 suspending = 12 [json_name = "suspending"];

  // [Output Only] The number of instances in the managed instance group that
  // are being verified. See the managedInstances[].currentAction property in
  // the listManagedInstances method documentation.
  optional int32 verifying = 13 [json_name = "verifying"];
}

message InstanceGroupManagerAllInstancesConfig {
  // Properties to set on all instances in the group. You can add or modify
  // properties using the instanceGroupManagers.patch or
  // regionInstanceGroupManagers.patch. After setting allInstancesConfig on the
  // group, you must update the group's instances to apply the configuration. To
  // apply the configuration, set the group's updatePolicy.type field to use
  // proactive updates or use the applyUpdatesToInstances method.
  optional InstancePropertiesPatch properties = 1 [json_name = "properties"];
}

message InstanceGroupManagerAutoHealingPolicy {
  // The URL for the health check that signals autohealing.
  optional string health_check = 1 [json_name = "healthCheck"];

  // The initial delay is the number of seconds that a new VM takes to
  // initialize and run its startup script. During a VM's initial delay period,
  // the MIG ignores unsuccessful health checks because the VM might be in the
  // startup process. This prevents the MIG from prematurely recreating a VM. If
  // the health check receives a healthy response during the initial delay, it
  // indicates that the startup process is complete and the VM is ready. The
  // value of initial delay must be between 0 and 3600 seconds. The default
  // value is 0.
  optional int32 initial_delay_sec = 2 [json_name = "initialDelaySec"];
}

message InstanceGroupManagerInstanceLifecyclePolicy {
  // The action that a MIG performs on a failed or an unhealthy VM. A VM is
  // marked as unhealthy when the application running on that VM fails a health
  // check. Valid values are - REPAIR (default): MIG automatically repairs a
  // failed or an unhealthy VM by recreating it. For more information, see About
  // repairing VMs in a MIG. - DO_NOTHING: MIG does not repair a failed or an
  // unhealthy VM.
  // DO_NOTHING: MIG does not repair a failed or an unhealthy VM.
  // REPAIR: (Default) MIG automatically repairs a failed or an unhealthy VM by
  // recreating it. For more information, see About repairing VMs in a MIG.
  optional string default_action_on_failure = 2
      [json_name = "defaultActionOnFailure"];

  // A bit indicating whether to forcefully apply the group's latest
  // configuration when repairing a VM. Valid options are: - NO (default): If
  // configuration updates are available, they are not forcefully applied during
  // repair. Instead, configuration updates are applied according to the group's
  // update policy. - YES: If configuration updates are available, they are
  // applied during repair.
  // NO:
  // YES:
  optional string force_update_on_repair = 1
      [json_name = "forceUpdateOnRepair"];
}

message InstanceGroupManagerStatus {
  // [Output only] Status of all-instances configuration on the group.
  optional InstanceGroupManagerStatusAllInstancesConfig all_instances_config = 5
      [json_name = "allInstancesConfig"];

  // [Output Only] The URL of the Autoscaler that targets this instance group
  // manager.
  optional string autoscaler = 1 [json_name = "autoscaler"];

  // [Output Only] A bit indicating whether the managed instance group is in a
  // stable state. A stable state means that: none of the instances in the
  // managed instance group is currently undergoing any type of change (for
  // example, creation, restart, or deletion); no future changes are scheduled
  // for instances in the managed instance group; and the managed instance group
  // itself is not being modified.
  optional bool is_stable = 2 [json_name = "isStable"];

  // [Output Only] Stateful status of the given Instance Group Manager.
  optional InstanceGroupManagerStatusStateful stateful = 3
      [json_name = "stateful"];

  // [Output Only] A status of consistency of Instances' versions with their
  // target version specified by version field on Instance Group Manager.
  optional InstanceGroupManagerStatusVersionTarget version_target = 4
      [json_name = "versionTarget"];
}

message InstanceGroupManagerStatusAllInstancesConfig {
  // [Output Only] Current all-instances configuration revision. This value is
  // in RFC3339 text format.
  optional string current_revision = 1 [json_name = "currentRevision"];

  // [Output Only] A bit indicating whether this configuration has been applied
  // to all managed instances in the group.
  optional bool effective = 2 [json_name = "effective"];
}

message InstanceGroupManagerStatusStateful {
  // [Output Only] A bit indicating whether the managed instance group has
  // stateful configuration, that is, if you have configured any items in a
  // stateful policy or in per-instance configs. The group might report that it
  // has no stateful configuration even when there is still some preserved state
  // on a managed instance, for example, if you have deleted all PICs but not
  // yet applied those deletions.
  optional bool has_stateful_config = 1 [json_name = "hasStatefulConfig"];

  // [Output Only] Status of per-instance configurations on the instance.
  optional InstanceGroupManagerStatusStatefulPerInstanceConfigs
      per_instance_configs = 2 [json_name = "perInstanceConfigs"];
}

message InstanceGroupManagerStatusStatefulPerInstanceConfigs {
  // A bit indicating if all of the group's per-instance configurations (listed
  // in the output of a listPerInstanceConfigs API call) have status EFFECTIVE
  // or there are no per-instance-configs.
  optional bool all_effective = 1 [json_name = "allEffective"];
}

message InstanceGroupManagerStatusVersionTarget {
  // [Output Only] A bit indicating whether version target has been reached in
  // this managed instance group, i.e. all instances are in their target
  // version. Instances' target version are specified by version field on
  // Instance Group Manager.
  optional bool is_reached = 1 [json_name = "isReached"];
}

message InstanceGroupManagerUpdatePolicy {
  // The instance redistribution policy for regional managed instance groups.
  // Valid values are: - PROACTIVE (default): The group attempts to maintain an
  // even distribution of VM instances across zones in the region. - NONE: For
  // non-autoscaled groups, proactive redistribution is disabled.
  // NONE: No action is being proactively performed in order to bring this IGM
  // to its target instance distribution.
  // PROACTIVE: This IGM will actively converge to its target instance
  // distribution.
  optional string instance_redistribution_type = 1
      [json_name = "instanceRedistributionType"];

  // The maximum number of instances that can be created above the specified
  // targetSize during the update process. This value can be either a fixed
  // number or, if the group has 10 or more instances, a percentage. If you set
  // a percentage, the number of instances is rounded if necessary. The default
  // value for maxSurge is a fixed value equal to the number of zones in which
  // the managed instance group operates. At least one of either maxSurge or
  // maxUnavailable must be greater than 0. Learn more about maxSurge.
  optional FixedOrPercent max_surge = 2 [json_name = "maxSurge"];

  // The maximum number of instances that can be unavailable during the update
  // process. An instance is considered available if all of the following
  // conditions are satisfied: - The instance's status is RUNNING. - If there is
  // a health check on the instance group, the instance's health check status
  // must be HEALTHY at least once. If there is no health check on the group,
  // then the instance only needs to have a status of RUNNING to be considered
  // available. This value can be either a fixed number or, if the group has 10
  // or more instances, a percentage. If you set a percentage, the number of
  // instances is rounded if necessary. The default value for maxUnavailable is
  // a fixed value equal to the number of zones in which the managed instance
  // group operates. At least one of either maxSurge or maxUnavailable must be
  // greater than 0. Learn more about maxUnavailable.
  optional FixedOrPercent max_unavailable = 3 [json_name = "maxUnavailable"];

  // Minimal action to be taken on an instance. Use this option to minimize
  // disruption as much as possible or to apply a more disruptive action than is
  // necessary. - To limit disruption as much as possible, set the minimal
  // action to REFRESH. If your update requires a more disruptive action,
  // Compute Engine performs the necessary action to execute the update. - To
  // apply a more disruptive action than is strictly necessary, set the minimal
  // action to RESTART or REPLACE. For example, Compute Engine does not need to
  // restart a VM to change its metadata. But if your application reads instance
  // metadata only when a VM is restarted, you can set the minimal action to
  // RESTART in order to pick up metadata changes.
  // NONE: Do not perform any action.
  // REFRESH: Do not stop the instance.
  // REPLACE: (Default.) Replace the instance according to the replacement
  // method option.
  // RESTART: Stop the instance and start it again.
  optional string minimal_action = 4 [json_name = "minimalAction"];

  // Most disruptive action that is allowed to be taken on an instance. You can
  // specify either NONE to forbid any actions, REFRESH to avoid restarting the
  // VM and to limit disruption as much as possible. RESTART to allow actions
  // that can be applied without instance replacing or REPLACE to allow all
  // possible actions. If the Updater determines that the minimal update action
  // needed is more disruptive than most disruptive allowed action you specify
  // it will not perform the update at all.
  // NONE: Do not perform any action.
  // REFRESH: Do not stop the instance.
  // REPLACE: (Default.) Replace the instance according to the replacement
  // method option.
  // RESTART: Stop the instance and start it again.
  optional string most_disruptive_allowed_action = 5
      [json_name = "mostDisruptiveAllowedAction"];

  // What action should be used to replace instances. See minimal_action.REPLACE
  // RECREATE: Instances will be recreated (with the same name)
  // SUBSTITUTE: Default option: instances will be deleted and created (with a
  // new name)
  optional string replacement_method = 6 [json_name = "replacementMethod"];

  // The type of update process. You can specify either PROACTIVE so that the
  // MIG automatically updates VMs to the latest configurations or OPPORTUNISTIC
  // so that you can select the VMs that you want to update.
  // OPPORTUNISTIC: MIG will apply new configurations to existing VMs only when
  // you selectively target specific or all VMs to be updated.
  // PROACTIVE: MIG will automatically apply new configurations to all or a
  // subset of existing VMs and also to new VMs that are added to the group.
  optional string type = 7 [json_name = "type"];
}

message InstanceGroupManagerVersion {
  // The URL of the instance template that is specified for this managed
  // instance group. The group uses this template to create new instances in the
  // managed instance group until the `targetSize` for this version is reached.
  // The templates for existing instances in the group do not change unless you
  // run recreateInstances, run applyUpdatesToInstances, or set the group's
  // updatePolicy.type to PROACTIVE; in those cases, existing instances are
  // updated until the `targetSize` for this version is reached.
  optional string instance_template = 1 [json_name = "instanceTemplate"];

  // Name of the version. Unique among all versions in the scope of this managed
  // instance group.
  optional string name = 2 [json_name = "name"];

  // Specifies the intended number of instances to be created from the
  // instanceTemplate. The final number of instances created from the template
  // will be equal to: - If expressed as a fixed number, the minimum of either
  // targetSize.fixed or instanceGroupManager.targetSize is used. - if expressed
  // as a percent, the targetSize would be (targetSize.percent/100 *
  // InstanceGroupManager.targetSize) If there is a remainder, the number is
  // rounded. If unset, this version will update any remaining instances not
  // updated by another version. Read Starting a canary update for more
  // information.
  optional FixedOrPercent target_size = 3 [json_name = "targetSize"];
}

message InstanceManagedByIgmError {
  // [Output Only] Contents of the error.
  optional InstanceManagedByIgmErrorManagedInstanceError error = 1
      [json_name = "error"];

  // [Output Only] Details of the instance action that triggered this error. May
  // be null, if the error was not caused by an action on an instance. This
  // field is optional.
  optional InstanceManagedByIgmErrorInstanceActionDetails
      instance_action_details = 2 [json_name = "instanceActionDetails"];

  // [Output Only] The time that this error occurred. This value is in RFC3339
  // text format.
  optional string timestamp = 3 [json_name = "timestamp"];
}

message InstanceManagedByIgmErrorInstanceActionDetails {
  // [Output Only] Action that managed instance group was executing on the
  // instance when the error occurred. Possible values:
  // ABANDONING: The managed instance group is abandoning this instance. The
  // instance will be removed from the instance group and from any target pools
  // that are associated with this group.
  // CREATING: The managed instance group is creating this instance. If the
  // group fails to create this instance, it will try again until it is
  // successful.
  // CREATING_WITHOUT_RETRIES: The managed instance group is attempting to
  // create this instance only once. If the group fails to create this instance,
  // it does not try again and the group's targetSize value is decreased.
  // DELETING: The managed instance group is permanently deleting this instance.
  // NONE: The managed instance group has not scheduled any actions for this
  // instance.
  // RECREATING: The managed instance group is recreating this instance.
  // REFRESHING: The managed instance group is applying configuration changes to
  // the instance without stopping it. For example, the group can update the
  // target pool list for an instance without stopping that instance.
  // RESTARTING: The managed instance group is restarting this instance.
  // RESUMING: The managed instance group is resuming this instance.
  // STARTING: The managed instance group is starting this instance.
  // STOPPING: The managed instance group is stopping this instance.
  // SUSPENDING: The managed instance group is suspending this instance.
  // VERIFYING: The managed instance group is verifying this already created
  // instance. Verification happens every time the instance is (re)created or
  // restarted and consists of: 1. Waiting until health check specified as part
  // of this managed instance group's autohealing policy reports HEALTHY. Note:
  // Applies only if autohealing policy has a health check specified 2. Waiting
  // for addition verification steps performed as post-instance creation
  // (subject to future extensions).
  optional string action = 1 [json_name = "action"];

  // [Output Only] The URL of the instance. The URL can be set even if the
  // instance has not yet been created.
  optional string instance = 2 [json_name = "instance"];

  // [Output Only] Version this instance was created from, or was being created
  // from, but the creation failed. Corresponds to one of the versions that were
  // set on the Instance Group Manager resource at the time this instance was
  // being created.
  optional ManagedInstanceVersion version = 3 [json_name = "version"];
}

message InstanceManagedByIgmErrorManagedInstanceError {
  // [Output Only] Error code.
  optional string code = 1 [json_name = "code"];

  // [Output Only] Error message.
  optional string message = 2 [json_name = "message"];
}

// Represents the change that you want to make to the instance properties.
message InstancePropertiesPatch {
  // The label key-value pairs that you want to patch onto the instance.
  map<string, string> labels = 1 [json_name = "labels"];

  // The metadata key-value pairs that you want to patch onto the instance. For
  // more information, see Project and instance metadata.
  map<string, string> metadata = 2 [json_name = "metadata"];
}

// A Managed Instance resource.
message ManagedInstance {
  // [Output Only] The current action that the managed instance group has
  // scheduled for the instance. Possible values: - NONE The instance is
  // running, and the managed instance group does not have any scheduled actions
  // for this instance. - CREATING The managed instance group is creating this
  // instance. If the group fails to create this instance, it will try again
  // until it is successful. - CREATING_WITHOUT_RETRIES The managed instance
  // group is attempting to create this instance only once. If the group fails
  // to create this instance, it does not try again and the group's targetSize
  // value is decreased instead. - RECREATING The managed instance group is
  // recreating this instance. - DELETING The managed instance group is
  // permanently deleting this instance. - ABANDONING The managed instance group
  // is abandoning this instance. The instance will be removed from the instance
  // group and from any target pools that are associated with this group. -
  // RESTARTING The managed instance group is restarting the instance. -
  // REFRESHING The managed instance group is applying configuration changes to
  // the instance without stopping it. For example, the group can update the
  // target pool list for an instance without stopping that instance. -
  // VERIFYING The managed instance group has created the instance and it is in
  // the process of being verified.
  // ABANDONING: The managed instance group is abandoning this instance. The
  // instance will be removed from the instance group and from any target pools
  // that are associated with this group.
  // CREATING: The managed instance group is creating this instance. If the
  // group fails to create this instance, it will try again until it is
  // successful.
  // CREATING_WITHOUT_RETRIES: The managed instance group is attempting to
  // create this instance only once. If the group fails to create this instance,
  // it does not try again and the group's targetSize value is decreased.
  // DELETING: The managed instance group is permanently deleting this instance.
  // NONE: The managed instance group has not scheduled any actions for this
  // instance.
  // RECREATING: The managed instance group is recreating this instance.
  // REFRESHING: The managed instance group is applying configuration changes to
  // the instance without stopping it. For example, the group can update the
  // target pool list for an instance without stopping that instance.
  // RESTARTING: The managed instance group is restarting this instance.
  // RESUMING: The managed instance group is resuming this instance.
  // STARTING: The managed instance group is starting this instance.
  // STOPPING: The managed instance group is stopping this instance.
  // SUSPENDING: The managed instance group is suspending this instance.
  // VERIFYING: The managed instance group is verifying this already created
  // instance. Verification happens every time the instance is (re)created or
  // restarted and consists of: 1. Waiting until health check specified as part
  // of this managed instance group's autohealing policy reports HEALTHY. Note:
  // Applies only if autohealing policy has a health check specified 2. Waiting
  // for addition verification steps performed as post-instance creation
  // (subject to future extensions).
  optional string current_action = 1 [json_name = "currentAction"];

  // [Output only] The unique identifier for this resource. This field is empty
  // when instance does not exist.
  optional string id = 2 [json_name = "id"];

  // [Output Only] The URL of the instance. The URL can exist even if the
  // instance has not yet been created.
  optional string instance = 3 [json_name = "instance"];

  // [Output Only] Health state of the instance per health-check.
  repeated ManagedInstanceInstanceHealth instance_health = 4
      [json_name = "instanceHealth"];

  // [Output Only] The status of the instance. This field is empty when the
  // instance does not exist.
  // DEPROVISIONING: The instance is halted and we are performing tear down
  // tasks like network deprogramming, releasing quota, IP, tearing down disks
  // etc.
  // PROVISIONING: Resources are being allocated for the instance.
  // REPAIRING: The instance is in repair.
  // RUNNING: The instance is running.
  // STAGING: All required resources have been allocated and the instance is
  // being started.
  // STOPPED: The instance has stopped successfully.
  // STOPPING: The instance is currently stopping (either being deleted or
  // killed).
  // SUSPENDED: The instance has suspended.
  // SUSPENDING: The instance is suspending.
  // TERMINATED: The instance has stopped (either by explicit action or
  // underlying failure).
  optional string instance_status = 5 [json_name = "instanceStatus"];

  // [Output Only] Information about the last attempt to create or delete the
  // instance.
  optional ManagedInstanceLastAttempt last_attempt = 6
      [json_name = "lastAttempt"];

  // [Output Only] The name of the instance. The name always exists even if the
  // instance has not yet been created.
  optional string name = 10 [json_name = "name"];

  // [Output Only] Preserved state applied from per-instance config for this
  // instance.
  optional PreservedState preserved_state_from_config = 7
      [json_name = "preservedStateFromConfig"];

  // [Output Only] Preserved state generated based on stateful policy for this
  // instance.
  optional PreservedState preserved_state_from_policy = 8
      [json_name = "preservedStateFromPolicy"];

  // [Output Only] Intended version of this instance.
  optional ManagedInstanceVersion version = 9 [json_name = "version"];
}

message ManagedInstanceInstanceHealth {
  // [Output Only] The current detailed instance health state.
  // DRAINING: The instance is being drained. The existing connections to the
  // instance have time to complete, but the new ones are being refused.
  // HEALTHY: The instance is reachable i.e. a connection to the application
  // health checking endpoint can be established, and conforms to the
  // requirements defined by the health check.
  // TIMEOUT: The instance is unreachable i.e. a connection to the application
  // health checking endpoint cannot be established, or the server does not
  // respond within the specified timeout.
  // UNHEALTHY: The instance is reachable, but does not conform to the
  // requirements defined by the health check.
  // UNKNOWN: The health checking system is aware of the instance but its health
  // is not known at the moment.
  optional string detailed_health_state = 1 [json_name = "detailedHealthState"];

  // [Output Only] The URL for the health check that verifies whether the
  // instance is healthy.
  optional string health_check = 2 [json_name = "healthCheck"];
}

message ManagedInstanceLastAttempt {
  message Errors {
    message ErrorsItem {
      // [Output Only] The error type identifier for this error.
      optional string code = 1 [json_name = "code"];

      message ErrorDetailsItem {
        optional ErrorInfo error_info = 1 [json_name = "errorInfo"];

        optional Help help = 2 [json_name = "help"];

        optional LocalizedMessage localized_message = 3
            [json_name = "localizedMessage"];

        optional QuotaExceededInfo quota_info = 4 [json_name = "quotaInfo"];
      }

      // [Output Only] An optional list of messages that contain the error
      // details. There is a set of defined message types to use for providing
      // details.The syntax depends on the error code. For example,
      // QuotaExceededInfo will have details when the error code is
      // QUOTA_EXCEEDED.
      repeated ErrorDetailsItem error_details = 2 [json_name = "errorDetails"];

      // [Output Only] Indicates the field in the request that caused the error.
      // This property is optional.
      optional string location = 3 [json_name = "location"];

      // [Output Only] An optional, human-readable error message.
      optional string message = 4 [json_name = "message"];
    }

    // [Output Only] The array of errors encountered while processing this
    // operation.
    repeated ErrorsItem errors = 1 [json_name = "errors"];
  }

  // [Output Only] Encountered errors during the last attempt to create or
  // delete the instance.
  optional Errors errors = 1 [json_name = "errors"];
}

message ManagedInstanceVersion {
  // [Output Only] The intended template of the instance. This field is empty
  // when current_action is one of { DELETING, ABANDONING }.
  optional string instance_template = 1 [json_name = "instanceTemplate"];

  // [Output Only] Name of the version.
  optional string name = 2 [json_name = "name"];
}

message PerInstanceConfig {
  // Fingerprint of this per-instance config. This field can be used in
  // optimistic locking. It is ignored when inserting a per-instance config. An
  // up-to-date fingerprint must be provided in order to update an existing
  // per-instance configuration or the field needs to be unset.
  optional string fingerprint = 1 [json_name = "fingerprint"];

  // The name of a per-instance configuration and its corresponding instance.
  // Serves as a merge key during UpdatePerInstanceConfigs operations, that is,
  // if a per-instance configuration with the same name exists then it will be
  // updated, otherwise a new one will be created for the VM instance with the
  // same name. An attempt to create a per-instance configconfiguration for a VM
  // instance that either doesn't exist or is not part of the group will result
  // in an error.
  optional string name = 2 [json_name = "name"];

  // The intended preserved state for the given instance. Does not contain
  // preserved state generated from a stateful policy.
  optional PreservedState preserved_state = 3 [json_name = "preservedState"];

  // The status of applying this per-instance configuration on the corresponding
  // managed instance.
  // APPLYING: The per-instance configuration is being applied to the instance,
  // but is not yet effective, possibly waiting for the instance to, for
  // example, REFRESH.
  // DELETING: The per-instance configuration deletion is being applied on the
  // instance, possibly waiting for the instance to, for example, REFRESH.
  // EFFECTIVE: The per-instance configuration is effective on the instance,
  // meaning that all disks, ips and metadata specified in this configuration
  // are attached or set on the instance.
  // NONE: *[Default]* The default status, when no per-instance configuration
  // exists.
  // UNAPPLIED: The per-instance configuration is set on an instance but not
  // been applied yet.
  // UNAPPLIED_DELETION: The per-instance configuration has been deleted, but
  // the deletion is not yet applied.
  optional string status = 4 [json_name = "status"];
}

// Preserved state for a given instance.
message PreservedState {
  // Preserved disks defined for this instance. This map is keyed with the
  // device names of the disks.
  map<string, PreservedStatePreservedDisk> disks = 1 [json_name = "disks"];

  // Preserved external IPs defined for this instance. This map is keyed with
  // the name of the network interface.
  map<string, PreservedStatePreservedNetworkIp> external_i_ps = 3
      [json_name = "externalIPs"];

  // Preserved internal IPs defined for this instance. This map is keyed with
  // the name of the network interface.
  map<string, PreservedStatePreservedNetworkIp> internal_i_ps = 4
      [json_name = "internalIPs"];

  // Preserved metadata defined for this instance.
  map<string, string> metadata = 2 [json_name = "metadata"];
}

message PreservedStatePreservedDisk {
  // These stateful disks will never be deleted during autohealing, update,
  // instance recreate operations. This flag is used to configure if the disk
  // should be deleted after it is no longer used by the group, e.g. when the
  // given instance or the whole MIG is deleted. Note: disks attached in
  // READ_ONLY mode cannot be auto-deleted.
  // NEVER:
  // ON_PERMANENT_INSTANCE_DELETION:
  optional string auto_delete = 1 [json_name = "autoDelete"];

  // The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
  // not specified, the default is to attach the disk in READ_WRITE mode.
  // READ_ONLY: Attaches this disk in read-only mode. Multiple VM instances can
  // use a disk in READ_ONLY mode at a time.
  // READ_WRITE: *[Default]* Attaches this disk in READ_WRITE mode. Only one VM
  // instance at a time can be attached to a disk in READ_WRITE mode.
  optional string mode = 2 [json_name = "mode"];

  // The URL of the disk resource that is stateful and should be attached to the
  // VM instance.
  optional string source = 3 [json_name = "source"];
}

message PreservedStatePreservedNetworkIp {
  // These stateful IPs will never be released during autohealing, update or VM
  // instance recreate operations. This flag is used to configure if the IP
  // reservation should be deleted after it is no longer used by the group, e.g.
  // when the given instance or the whole group is deleted.
  // NEVER:
  // ON_PERMANENT_INSTANCE_DELETION:
  optional string auto_delete = 1 [json_name = "autoDelete"];

  // Ip address representation
  optional PreservedStatePreservedNetworkIpIpAddress ip_address = 2
      [json_name = "ipAddress"];
}

message PreservedStatePreservedNetworkIpIpAddress {
  // The URL of the reservation for this IP address.
  optional string address = 1 [json_name = "address"];

  // An IPv4 internal network address to assign to the instance for this network
  // interface.
  optional string literal = 2 [json_name = "literal"];
}

message StatefulPolicy {
  optional StatefulPolicyPreservedState preserved_state = 1
      [json_name = "preservedState"];
}

// Configuration of preserved resources.
message StatefulPolicyPreservedState {
  // Disks created on the instances that will be preserved on instance delete,
  // update, etc. This map is keyed with the device names of the disks.
  map<string, StatefulPolicyPreservedStateDiskDevice> disks = 1
      [json_name = "disks"];

  // External network IPs assigned to the instances that will be preserved on
  // instance delete, update, etc. This map is keyed with the network interface
  // name.
  map<string, StatefulPolicyPreservedStateNetworkIp> external_i_ps = 2
      [json_name = "externalIPs"];

  // Internal network IPs assigned to the instances that will be preserved on
  // instance delete, update, etc. This map is keyed with the network interface
  // name.
  map<string, StatefulPolicyPreservedStateNetworkIp> internal_i_ps = 3
      [json_name = "internalIPs"];
}

message StatefulPolicyPreservedStateDiskDevice {
  // These stateful disks will never be deleted during autohealing, update or VM
  // instance recreate operations. This flag is used to configure if the disk
  // should be deleted after it is no longer used by the group, e.g. when the
  // given instance or the whole group is deleted. Note: disks attached in
  // READ_ONLY mode cannot be auto-deleted.
  // NEVER:
  // ON_PERMANENT_INSTANCE_DELETION:
  optional string auto_delete = 1 [json_name = "autoDelete"];
}

message StatefulPolicyPreservedStateNetworkIp {
  // These stateful IPs will never be released during autohealing, update or VM
  // instance recreate operations. This flag is used to configure if the IP
  // reservation should be deleted after it is no longer used by the group, e.g.
  // when the given instance or the whole group is deleted.
  // NEVER:
  // ON_PERMANENT_INSTANCE_DELETION:
  optional string auto_delete = 1 [json_name = "autoDelete"];
}
